Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,49 +0,0 @@
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/vcs.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/vcs.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/Pathfinder.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/Pathfinder.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CreatePatchCommitExecutor\">\n    <option name=\"PATCH_PATH\" value=\"\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"MavenImportPreferences\">\n    <option name=\"generalSettings\">\n      <MavenGeneralSettings>\n        <option name=\"mavenHome\" value=\"Bundled (Maven 3)\" />\n      </MavenGeneralSettings>\n    </option>\n  </component>\n  <component name=\"ProjectId\" id=\"1iwYeHoVYqUfESIMNqB9GfLh0Bl\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/Users/jaylynhenegar/Desktop/22-23SchoolYear/22Semester/COS 265/P04_Pathfinding&quot;\n  }\n}</component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"Applet\">\n      <option name=\"POLICY_FILE\" value=\"$APPLICATION_HOME_DIR$/bin/appletviewer.policy\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidRunConfigurationType\" factoryName=\"Android App\">\n      <option name=\"DEPLOY\" value=\"true\" />\n      <option name=\"DEPLOY_APK_FROM_BUNDLE\" value=\"false\" />\n      <option name=\"DEPLOY_AS_INSTANT\" value=\"false\" />\n      <option name=\"ARTIFACT_NAME\" value=\"\" />\n      <option name=\"PM_INSTALL_OPTIONS\" value=\"\" />\n      <option name=\"ALL_USERS\" value=\"false\" />\n      <option name=\"ALWAYS_INSTALL_WITH_PM\" value=\"false\" />\n      <option name=\"DYNAMIC_FEATURES_DISABLED_LIST\" value=\"\" />\n      <option name=\"ACTIVITY_EXTRA_FLAGS\" value=\"\" />\n      <option name=\"MODE\" value=\"default_activity\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <option name=\"DEEP_LINK\" value=\"\" />\n      <option name=\"ACTIVITY_CLASS\" value=\"\" />\n      <option name=\"SEARCH_ACTIVITY_IN_GLOBAL_SCOPE\" value=\"false\" />\n      <option name=\"SKIP_ACTIVITY_VALIDATION\" value=\"false\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidTestRunConfigurationType\" factoryName=\"Android Instrumented Tests\">\n      <option name=\"TESTING_TYPE\" value=\"0\" />\n      <option name=\"METHOD_NAME\" value=\"\" />\n      <option name=\"CLASS_NAME\" value=\"\" />\n      <option name=\"PACKAGE_NAME\" value=\"\" />\n      <option name=\"INSTRUMENTATION_RUNNER_CLASS\" value=\"\" />\n      <option name=\"EXTRA_OPTIONS\" value=\"\" />\n      <option name=\"INCLUDE_GRADLE_EXTRA_OPTIONS\" value=\"true\" />\n      <option name=\"RETENTION_ENABLED\" value=\"No\" />\n      <option name=\"RETENTION_MAX_SNAPSHOTS\" value=\"2\" />\n      <option name=\"RETENTION_COMPRESS_SNAPSHOTS\" value=\"false\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"InteractivePathfinderVisualizer\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"InteractivePathfinderVisualizer\" />\n      <module name=\"P04_Pathfinding\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Application\" factoryName=\"Application\">\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JUnit\" factoryName=\"JUnit\">\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$MODULE_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JarApplication\">\n      <option name=\"JAR_PATH\" value=\"$PROJECT_DIR$/src/stdlib.jar\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"TestNG\">\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <properties />\n      <listeners />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"#org.jetbrains.idea.devkit.run.PluginConfigurationType\">\n      <module name=\"\" />\n      <option name=\"VM_PARAMETERS\" value=\"-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea\" />\n      <option name=\"PROGRAM_PARAMETERS\" />\n      <predefined_log_file enabled=\"true\" id=\"idea.log\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.InteractivePathfinderVisualizer\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"SvnConfiguration\">\n    <configuration />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\" />\n      <created>1437589218980</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1437589218980</updated>\n    </task>\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.UiProperties\">\n    <option name=\"RECENTLY_FILTERED_USER_GROUPS\">\n      <collection />\n    </option>\n    <option name=\"RECENTLY_FILTERED_BRANCH_GROUPS\">\n      <collection />\n    </option>\n  </component>\n  <component name=\"antWorkspaceConfiguration\">\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\n  </component>\n  <component name=\"masterDetails\">\n    <states>\n      <state key=\"ArtifactsStructureConfigurable.UI\">\n        <settings>\n          <artifact-editor />\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"FacetStructureConfigurable.UI\">\n        <settings>\n          <last-edited>No facets are configured</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"GlobalLibrariesConfigurable.UI\">\n        <settings>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"JdkListConfigurable.UI\">\n        <settings>\n          <last-edited>1.8</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ModuleStructureConfigurable.UI\">\n        <settings>\n          <last-edited>P04_Pathfinding</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n                <option value=\"0.6\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectJDKs.UI\">\n        <settings>\n          <last-edited>1.7</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectLibrariesConfigurable.UI\">\n        <settings>\n          <last-edited>algs4</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n    </states>\n  </component>\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 4a25ed2698823ce5825bc66c5a5c767c54af7731)
-+++ b/.idea/workspace.xml	(date 1666790559999)
-@@ -1,11 +1,7 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="ChangeListManager">
--    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="">
--      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/src/Pathfinder.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Pathfinder.java" afterDir="false" />
--    </list>
-+    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="commit" />
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
-@@ -175,6 +171,14 @@
-       <option name="presentableId" value="Default" />
-       <updated>1437589218980</updated>
-     </task>
-+    <task id="LOCAL-00001" summary="commit">
-+      <created>1666713264499</created>
-+      <option name="number" value="00001" />
-+      <option name="presentableId" value="LOCAL-00001" />
-+      <option name="project" value="LOCAL" />
-+      <updated>1666713264499</updated>
-+    </task>
-+    <option name="localTasksCounter" value="2" />
-     <servers />
-   </component>
-   <component name="Vcs.Log.Tabs.Properties">
-@@ -195,6 +199,10 @@
-     <option name="RECENTLY_FILTERED_BRANCH_GROUPS">
-       <collection />
-     </option>
-+  </component>
-+  <component name="VcsManagerConfiguration">
-+    <MESSAGE value="commit" />
-+    <option name="LAST_COMMIT_MESSAGE" value="commit" />
-   </component>
-   <component name="antWorkspaceConfiguration">
-     <option name="IS_AUTOSCROLL_TO_SOURCE" value="false" />
Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]" date="1666713322722" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10/25/22, 11:54 AM [Default]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,29 +0,0 @@
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"testingpush\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/Pathfinder.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/Pathfinder.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CreatePatchCommitExecutor\">\n    <option name=\"PATCH_PATH\" value=\"\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MavenImportPreferences\">\n    <option name=\"generalSettings\">\n      <MavenGeneralSettings>\n        <option name=\"mavenHome\" value=\"Bundled (Maven 3)\" />\n      </MavenGeneralSettings>\n    </option>\n  </component>\n  <component name=\"ProjectId\" id=\"1iwYeHoVYqUfESIMNqB9GfLh0Bl\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"PropertiesComponent\">\n    <property name=\"FullScreen\" value=\"false\" />\n    <property name=\"OverrideImplement.combined\" value=\"true\" />\n    <property name=\"OverrideImplement.overriding.sorted\" value=\"false\" />\n    <property name=\"dynamic.classpath\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"project.structure.last.edited\" value=\"Libraries\" />\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\n    <property name=\"recentsLimit\" value=\"5\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"preferences.pluginManager\" />\n    <property name=\"settings.editor.splitter.proportion\" value=\"0.2\" />\n  </component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"Applet\">\n      <option name=\"POLICY_FILE\" value=\"$APPLICATION_HOME_DIR$/bin/appletviewer.policy\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidRunConfigurationType\" factoryName=\"Android App\">\n      <option name=\"DEPLOY\" value=\"true\" />\n      <option name=\"DEPLOY_APK_FROM_BUNDLE\" value=\"false\" />\n      <option name=\"DEPLOY_AS_INSTANT\" value=\"false\" />\n      <option name=\"ARTIFACT_NAME\" value=\"\" />\n      <option name=\"PM_INSTALL_OPTIONS\" value=\"\" />\n      <option name=\"ALL_USERS\" value=\"false\" />\n      <option name=\"ALWAYS_INSTALL_WITH_PM\" value=\"false\" />\n      <option name=\"DYNAMIC_FEATURES_DISABLED_LIST\" value=\"\" />\n      <option name=\"ACTIVITY_EXTRA_FLAGS\" value=\"\" />\n      <option name=\"MODE\" value=\"default_activity\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <option name=\"DEEP_LINK\" value=\"\" />\n      <option name=\"ACTIVITY_CLASS\" value=\"\" />\n      <option name=\"SEARCH_ACTIVITY_IN_GLOBAL_SCOPE\" value=\"false\" />\n      <option name=\"SKIP_ACTIVITY_VALIDATION\" value=\"false\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidTestRunConfigurationType\" factoryName=\"Android Instrumented Tests\">\n      <option name=\"TESTING_TYPE\" value=\"0\" />\n      <option name=\"METHOD_NAME\" value=\"\" />\n      <option name=\"CLASS_NAME\" value=\"\" />\n      <option name=\"PACKAGE_NAME\" value=\"\" />\n      <option name=\"INSTRUMENTATION_RUNNER_CLASS\" value=\"\" />\n      <option name=\"EXTRA_OPTIONS\" value=\"\" />\n      <option name=\"INCLUDE_GRADLE_EXTRA_OPTIONS\" value=\"true\" />\n      <option name=\"RETENTION_ENABLED\" value=\"No\" />\n      <option name=\"RETENTION_MAX_SNAPSHOTS\" value=\"2\" />\n      <option name=\"RETENTION_COMPRESS_SNAPSHOTS\" value=\"false\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"InteractivePathfinderVisualizer\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"InteractivePathfinderVisualizer\" />\n      <module name=\"P04_Pathfinding\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Application\" factoryName=\"Application\">\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JUnit\" factoryName=\"JUnit\">\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$MODULE_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JarApplication\">\n      <option name=\"JAR_PATH\" value=\"$PROJECT_DIR$/src/stdlib.jar\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"TestNG\">\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <properties />\n      <listeners />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"#org.jetbrains.idea.devkit.run.PluginConfigurationType\">\n      <module name=\"\" />\n      <option name=\"VM_PARAMETERS\" value=\"-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea\" />\n      <option name=\"PROGRAM_PARAMETERS\" />\n      <predefined_log_file enabled=\"true\" id=\"idea.log\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.InteractivePathfinderVisualizer\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SvnConfiguration\">\n    <configuration />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\" />\n      <created>1437589218980</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1437589218980</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"testingpush\">\n      <created>1666713359136</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1666713359137</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"testingpush\">\n      <created>1666787253246</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1666787253246</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"3\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.UiProperties\">\n    <option name=\"RECENTLY_FILTERED_USER_GROUPS\">\n      <collection />\n    </option>\n    <option name=\"RECENTLY_FILTERED_BRANCH_GROUPS\">\n      <collection />\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"testingpush\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"testingpush\" />\n  </component>\n  <component name=\"antWorkspaceConfiguration\">\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\n  </component>\n  <component name=\"masterDetails\">\n    <states>\n      <state key=\"ArtifactsStructureConfigurable.UI\">\n        <settings>\n          <artifact-editor />\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"FacetStructureConfigurable.UI\">\n        <settings>\n          <last-edited>No facets are configured</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"GlobalLibrariesConfigurable.UI\">\n        <settings>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"JdkListConfigurable.UI\">\n        <settings>\n          <last-edited>1.8</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ModuleStructureConfigurable.UI\">\n        <settings>\n          <last-edited>P04_Pathfinding</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n                <option value=\"0.6\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectJDKs.UI\">\n        <settings>\n          <last-edited>1.7</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectLibrariesConfigurable.UI\">\n        <settings>\n          <last-edited>algs4</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n    </states>\n  </component>\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 6cf072a973f0e9b5df5708bc22f87d48cea5f3c0)
-+++ b/.idea/workspace.xml	(date 1666799143639)
-@@ -1,9 +1,8 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="ChangeListManager">
--    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="testingpush">
-+    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="commit">
-       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/src/Pathfinder.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Pathfinder.java" afterDir="false" />
-     </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-@@ -161,6 +160,7 @@
-       </list>
-     </recent_temporary>
-   </component>
-+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
-   <component name="SvnConfiguration">
-     <configuration />
-   </component>
Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,277 +0,0 @@
-Index: src/InteractivePathfinderVisualizer.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import java.awt.event.KeyEvent;\n\n/**\n * InteractivePathfinderVisualizer visualizes the terrain and the computed\n * path and allows the user to change parameters of the Pathfinder.  Below\n * is a list of commands and what they do.  Note: some of the commands\n * modify the properties of the path finder and some modify the terrain.\n *\n * Command        Action                                      Terrain\n * C              clear path\n * space          recompute path\n * S/E            set start/end location to mouse\n * left/right     halve/double path search heuristic value\n * 0/1            set path search heuristic to 0 or 1\n * W              start a walker to show the path\n * R              randomly generate a new terrain                *\n * M              smooths terrain under mouse                    *\n * shift+M        smooths all terrain                            *\n * up/down        increase/decrease terrain under mouse          *\n */\n\npublic class InteractivePathfinderVisualizer {\n    private final static int DELAY = 10;\n\n    // sets how many redraws it should take for the walker to reach its destination\n    private final static float STEPS_TO_WALK = 100.0f;\n\n    // for convenience, here are the emap files that are located under heightmaps/ folder\n    // the python script in that folder converts png files to emap. \\\n    // you can use it to create your own maps to test your code\n    private final static String[] emaps = {\n            \"maze32_0.png.emap\",    // 0   (32x32 maze)\n            \"maze32_1.png.emap\",    // 1   (another 32x32 maze)\n            \"maze232_0.png.emap\",   // 2   (232x232 maze)\n            \"maze320_0.png.emap\",   // 3   (same as maze32_0, only scaled up by 10x)\n            \"mazeAB.png.emap\",      // 4   (a maze from a site no longer online :( )\n            \"mazeBrain.png.emap\",   // 5   (...)\n            \"ramp.png.emap\",        // 6   (some tests)\n            \"ramp2.png.emap\",       // 7   (...)\n            \"ramp3.png.emap\",       // 8   (...)\n            \"usa128.png.emap\",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)\n            \"usa256.png.emap\",      // 10  (same as usa128, only higher resolution)\n            \"usa1024.png.emap\",     // 11  (same as usa128, only higher resolution\n    };\n\n    private final static String emapFilename = emaps[2];        // change index to load a different elevation map\n\n\n\n    public static void main(String[] args) {\n        Terrain terrain = new Terrain(emapFilename);\n        Pathfinder pf = new Pathfinder(terrain);\n        int N = terrain.getN();\n\n        StdDraw.show(0);\n\n        // set default starting and ending locations\n        pf.setPathStart(new Coord(1, 1));\n        pf.setPathEnd(new Coord(N-3, N-3));\n\n        // find a path\n        pf.resetPath();\n        pf.computePath();\n\n        PathfinderVisualizer.draw(terrain, pf, null, N);\n        StdDraw.show(DELAY);\n\n        // prevent repeated applications\n        boolean keyboardR = false;\n        boolean keyboardM = false;\n\n        Walker walker = null;\n\n        while(true) {\n            boolean recompute = false;\n            boolean redraw = false;\n\n            // mouse location on map\n            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);\n            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);\n            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {\n                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);\n                float m = keyboardLeft ? 0.5f : 2.0f;\n                float h = pf.getHeuristic() * m;\n                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));\n                pf.setHeuristic(h);\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {\n                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);\n                float h = keyboard0 ? 0 : 1;\n                pf.setHeuristic(h);\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {\n                pf.resetPath();\n                walker = null;\n                redraw = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {\n                TerrainEditor.setFractalHeights(terrain);\n                TerrainEditor.clampHeights(terrain);\n                recompute = true;\n            }\n            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {\n                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {\n                    if(!keyboardM) {\n                        TerrainEditor.smoothHeights(terrain);\n                        recompute = true;\n                    }\n                } else {\n                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);\n                    recompute = true;\n                }\n            }\n            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {\n                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);\n                float add = keyboardUp ? 8.0f : -8.0f;\n                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);\n                recompute = true;\n            }\n\n            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {\n                pf.setPathStart(new Coord(mouseI, mouseJ));\n                recompute = true;\n            }\n\n            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {\n                pf.setPathEnd(new Coord(mouseI, mouseJ));\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {\n                Iterable<Coord> path = pf.getPathSolution();\n                if(path != null) {\n                    walker = new Walker(terrain, pf.getPathSolution());\n                }\n            }\n\n            if(walker != null) {\n                if(walker.doneWalking()) {\n                    walker = null;\n                } else {\n                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);\n                }\n                redraw = true;\n            }\n\n            if(recompute) {\n                walker = null;\n                pf.resetPath();\n                if(pf.getPathStart() != null && pf.getPathEnd() != null) {\n                    pf.computePath();\n                }\n                redraw = true;\n            }\n\n            if(redraw) {\n                PathfinderVisualizer.draw(terrain, pf, walker, N);\n                StdDraw.show(DELAY);\n            } else {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    /* do nothing */\n                }\n            }\n        }\n    }\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/InteractivePathfinderVisualizer.java b/src/InteractivePathfinderVisualizer.java
---- a/src/InteractivePathfinderVisualizer.java	(revision 8d2d97a18f77e17c906c6f06e314308254d3014d)
-+++ b/src/InteractivePathfinderVisualizer.java	(date 1666710043190)
-@@ -1,5 +1,5 @@
- import java.awt.event.KeyEvent;
--
-+//kate was here
- /**
-  * InteractivePathfinderVisualizer visualizes the terrain and the computed
-  * path and allows the user to change parameters of the Pathfinder.  Below
-Index: src/Pathfinder.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import java.lang.IndexOutOfBoundsException;\nimport java.lang.IllegalArgumentException;\n\n/**\n * Pathfinder uses A* search to find a near optimal path\n * between to locations with given terrain.\n */\n\npublic class Pathfinder {\n\n    /**\n     * PFNode will be the key for MinPQ (used in computePath())\n     */\n    private class PFNode implements Comparable<PFNode> {\n        // loc: the location of the PFNode\n        // fromNode: how did we get here? (linked list back to start)\n        public PFNode(Coord loc, PFNode fromNode) { }\n\n        // compares this with that, used to find minimum cost PFNode\n        public int compareTo(PFNode that) {\n            return 0;\n        }\n\n        // returns the cost to travel from starting point to this\n        // via the fromNode chain\n        public float getCost(float heuristic) {\n            return 0;\n        }\n\n        // returns if this PFNode is still valid\n        public boolean isValid() {\n            return false;\n        }\n\n        // invalidates the PFNode\n        public void invalidate() {\n        }\n\n        // returns if the PFNode has been used\n        public boolean isUsed() {\n            return true;\n        }\n\n        // uses the PFNode\n        public void use() { }\n\n        // returns an Iterable of PFNodes that surround this\n        public Iterable<PFNode> neighbors() {\n            Stack<PFNode> s = new Stack<>();\n            s.push(new PFNode(null, null));\n            return s;\n        }\n    }\n\n    public Pathfinder(Terrain terrain) {\n    }\n\n    public void setPathStart(Coord loc) {\n    }\n\n    public Coord getPathStart() {\n        return null;\n    }\n\n    public void setPathEnd(Coord loc) {\n    }\n\n    public Coord getPathEnd() {\n        return null;\n    }\n\n    public void setHeuristic(float v) {\n    }\n\n    public float getHeuristic() {\n        return 0;\n    }\n\n    public void resetPath() {\n    }\n\n    public void computePath() {\n    }\n\n    public boolean foundPath() {\n        return false;\n    }\n\n    public float getPathCost() {\n        return 0;\n    }\n\n    public int getSearchSize() {\n        return 0;\n    }\n\n    public Iterable<Coord> getPathSolution() {\n        return null;\n    }\n\n    public boolean wasSearched(Coord loc) {\n        return false;\n    }\n}\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/Pathfinder.java b/src/Pathfinder.java
---- a/src/Pathfinder.java	(revision 8d2d97a18f77e17c906c6f06e314308254d3014d)
-+++ b/src/Pathfinder.java	(date 1666712959172)
-@@ -14,11 +14,12 @@
-     private class PFNode implements Comparable<PFNode> {
-         // loc: the location of the PFNode
-         // fromNode: how did we get here? (linked list back to start)
--        public PFNode(Coord loc, PFNode fromNode) { }
-+        public PFNode(Coord loc, PFNode fromNode) {
-+        }
- 
-         // compares this with that, used to find minimum cost PFNode
-         public int compareTo(PFNode that) {
--            return 0;
-+            return this.compareTo(that);        //???
-         }
- 
-         // returns the cost to travel from starting point to this
-@@ -52,21 +53,22 @@
-         }
-     }
- 
-+    Coord pathStart = null;
-+    Coord pathEnd = null;
-     public Pathfinder(Terrain terrain) {
-     }
--
-     public void setPathStart(Coord loc) {
-+        pathStart = loc;
-     }
--
-     public Coord getPathStart() {
--        return null;
-+        return pathStart;
-     }
- 
-     public void setPathEnd(Coord loc) {
-+        pathEnd = loc;
-     }
--
-     public Coord getPathEnd() {
--        return null;
-+        return pathEnd;
-     }
- 
-     public void setHeuristic(float v) {
-@@ -80,6 +82,7 @@
-     }
- 
-     public void computePath() {
-+
-     }
- 
-     public boolean foundPath() {
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\" />\n    <option name=\"EXCLUDED_CONVERTED_TO_IGNORED\" value=\"true\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CreatePatchCommitExecutor\">\n    <option name=\"PATCH_PATH\" value=\"\" />\n  </component>\n  <component name=\"FavoritesManager\">\n    <favorites_list name=\"P04_Pathfinding\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/../../../..\" />\n  </component>\n  <component name=\"MavenImportPreferences\">\n    <option name=\"generalSettings\">\n      <MavenGeneralSettings>\n        <option name=\"mavenHome\" value=\"Bundled (Maven 3)\" />\n      </MavenGeneralSettings>\n    </option>\n  </component>\n  <component name=\"ProjectId\" id=\"1iwYeHoVYqUfESIMNqB9GfLh0Bl\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"PropertiesComponent\">\n    <property name=\"FullScreen\" value=\"false\" />\n    <property name=\"OverrideImplement.combined\" value=\"true\" />\n    <property name=\"OverrideImplement.overriding.sorted\" value=\"false\" />\n    <property name=\"dynamic.classpath\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"project.structure.last.edited\" value=\"Libraries\" />\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\n    <property name=\"recentsLimit\" value=\"5\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"preferences.pluginManager\" />\n    <property name=\"settings.editor.splitter.proportion\" value=\"0.2\" />\n  </component>\n  <component name=\"RunDashboard\">\n    <option name=\"ruleStates\">\n      <list>\n        <RuleState>\n          <option name=\"name\" value=\"ConfigurationTypeDashboardGroupingRule\" />\n        </RuleState>\n        <RuleState>\n          <option name=\"name\" value=\"StatusDashboardGroupingRule\" />\n        </RuleState>\n      </list>\n    </option>\n  </component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"AndroidRunConfigurationType\">\n      <option name=\"DEPLOY\" value=\"true\" />\n      <option name=\"DEPLOY_APK_FROM_BUNDLE\" value=\"false\" />\n      <option name=\"DEPLOY_AS_INSTANT\" value=\"false\" />\n      <option name=\"ARTIFACT_NAME\" value=\"\" />\n      <option name=\"PM_INSTALL_OPTIONS\" value=\"\" />\n      <option name=\"DYNAMIC_FEATURES_DISABLED_LIST\" value=\"\" />\n      <option name=\"ACTIVITY_EXTRA_FLAGS\" value=\"\" />\n      <option name=\"MODE\" value=\"default_activity\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"SKIP_NOOP_APK_INSTALLATIONS\" value=\"true\" />\n      <option name=\"FORCE_STOP_RUNNING_APP\" value=\"true\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"USE_LAST_SELECTED_DEVICE\" value=\"false\" />\n      <option name=\"PREFERRED_AVD\" value=\"\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n      </Profilers>\n      <option name=\"DEEP_LINK\" value=\"\" />\n      <option name=\"ACTIVITY_CLASS\" value=\"\" />\n      <method v=\"2\">\n        <option name=\"Android.Gradle.BeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidTestRunConfigurationType\">\n      <option name=\"TESTING_TYPE\" value=\"0\" />\n      <option name=\"INSTRUMENTATION_RUNNER_CLASS\" value=\"\" />\n      <option name=\"METHOD_NAME\" value=\"\" />\n      <option name=\"CLASS_NAME\" value=\"\" />\n      <option name=\"PACKAGE_NAME\" value=\"\" />\n      <option name=\"EXTRA_OPTIONS\" value=\"\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"SKIP_NOOP_APK_INSTALLATIONS\" value=\"true\" />\n      <option name=\"FORCE_STOP_RUNNING_APP\" value=\"true\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"USE_LAST_SELECTED_DEVICE\" value=\"false\" />\n      <option name=\"PREFERRED_AVD\" value=\"\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n      </Profilers>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n        <option name=\"Android.Gradle.BeforeRunTask\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Applet\">\n      <option name=\"POLICY_FILE\" value=\"$APPLICATION_HOME_DIR$/bin/appletviewer.policy\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"InteractivePathfinderVisualizer\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"InteractivePathfinderVisualizer\" />\n      <module name=\"P04_Pathfinding\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Application\" factoryName=\"Application\">\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JUnit\" factoryName=\"JUnit\">\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$MODULE_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JarApplication\">\n      <option name=\"JAR_PATH\" value=\"$PROJECT_DIR$/src/stdlib.jar\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"TestNG\">\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <properties />\n      <listeners />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"#org.jetbrains.idea.devkit.run.PluginConfigurationType\">\n      <module name=\"\" />\n      <option name=\"VM_PARAMETERS\" value=\"-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea\" />\n      <option name=\"PROGRAM_PARAMETERS\" />\n      <predefined_log_file enabled=\"true\" id=\"idea.log\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.InteractivePathfinderVisualizer\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SvnConfiguration\">\n    <configuration />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\" />\n      <created>1437589218980</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1437589218980</updated>\n    </task>\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.UiProperties\">\n    <option name=\"RECENTLY_FILTERED_USER_GROUPS\">\n      <collection />\n    </option>\n    <option name=\"RECENTLY_FILTERED_BRANCH_GROUPS\">\n      <collection />\n    </option>\n  </component>\n  <component name=\"antWorkspaceConfiguration\">\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\n  </component>\n  <component name=\"masterDetails\">\n    <states>\n      <state key=\"ArtifactsStructureConfigurable.UI\">\n        <settings>\n          <artifact-editor />\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"FacetStructureConfigurable.UI\">\n        <settings>\n          <last-edited>No facets are configured</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"GlobalLibrariesConfigurable.UI\">\n        <settings>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"JdkListConfigurable.UI\">\n        <settings>\n          <last-edited>1.8</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ModuleStructureConfigurable.UI\">\n        <settings>\n          <last-edited>P04_Pathfinding</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n                <option value=\"0.6\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectJDKs.UI\">\n        <settings>\n          <last-edited>1.7</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectLibrariesConfigurable.UI\">\n        <settings>\n          <last-edited>algs4</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n    </states>\n  </component>\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 8d2d97a18f77e17c906c6f06e314308254d3014d)
-+++ b/.idea/workspace.xml	(date 1666712959531)
-@@ -1,8 +1,12 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="ChangeListManager">
--    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="" />
--    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
-+    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="">
-+      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/InteractivePathfinderVisualizer.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/InteractivePathfinderVisualizer.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/Pathfinder.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Pathfinder.java" afterDir="false" />
-+    </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
-@@ -11,9 +15,6 @@
-   <component name="CreatePatchCommitExecutor">
-     <option name="PATCH_PATH" value="" />
-   </component>
--  <component name="FavoritesManager">
--    <favorites_list name="P04_Pathfinding" />
--  </component>
-   <component name="FileTemplateManagerImpl">
-     <option name="RECENT_TEMPLATES">
-       <list>
-@@ -22,7 +23,10 @@
-     </option>
-   </component>
-   <component name="Git.Settings">
--    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/../../../.." />
-+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-+  </component>
-+  <component name="MarkdownSettingsMigration">
-+    <option name="stateVersion" value="1" />
-   </component>
-   <component name="MavenImportPreferences">
-     <option name="generalSettings">
-@@ -33,89 +37,78 @@
-   </component>
-   <component name="ProjectId" id="1iwYeHoVYqUfESIMNqB9GfLh0Bl" />
-   <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
--  <component name="PropertiesComponent">
--    <property name="FullScreen" value="false" />
--    <property name="OverrideImplement.combined" value="true" />
--    <property name="OverrideImplement.overriding.sorted" value="false" />
--    <property name="dynamic.classpath" value="false" />
--    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
--    <property name="project.structure.last.edited" value="Libraries" />
--    <property name="project.structure.proportion" value="0.15" />
--    <property name="project.structure.side.proportion" value="0.2" />
--    <property name="recentsLimit" value="5" />
--    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
--    <property name="settings.editor.splitter.proportion" value="0.2" />
--  </component>
--  <component name="RunDashboard">
--    <option name="ruleStates">
--      <list>
--        <RuleState>
--          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
--        </RuleState>
--        <RuleState>
--          <option name="name" value="StatusDashboardGroupingRule" />
--        </RuleState>
--      </list>
--    </option>
-+  <component name="ProjectViewState">
-+    <option name="hideEmptyMiddlePackages" value="true" />
-+    <option name="showLibraryContents" value="true" />
-   </component>
-+  <component name="PropertiesComponent"><![CDATA[{
-+  "keyToString": {
-+    "last_opened_file_path": "/Users/katemikels/Documents/COS265/P04_Pathfinding/pathfinding"
-+  }
-+}]]></component>
-   <component name="RunManager">
--    <configuration default="true" type="AndroidRunConfigurationType">
-+    <configuration default="true" type="Applet">
-+      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
-+      <method v="2">
-+        <option name="Make" enabled="true" />
-+      </method>
-+    </configuration>
-+    <configuration default="true" type="AndroidRunConfigurationType" factoryName="Android App">
-       <option name="DEPLOY" value="true" />
-       <option name="DEPLOY_APK_FROM_BUNDLE" value="false" />
-       <option name="DEPLOY_AS_INSTANT" value="false" />
-       <option name="ARTIFACT_NAME" value="" />
-       <option name="PM_INSTALL_OPTIONS" value="" />
-+      <option name="ALL_USERS" value="false" />
-+      <option name="ALWAYS_INSTALL_WITH_PM" value="false" />
-       <option name="DYNAMIC_FEATURES_DISABLED_LIST" value="" />
-       <option name="ACTIVITY_EXTRA_FLAGS" value="" />
-       <option name="MODE" value="default_activity" />
-       <option name="CLEAR_LOGCAT" value="false" />
-       <option name="SHOW_LOGCAT_AUTOMATICALLY" value="true" />
--      <option name="SKIP_NOOP_APK_INSTALLATIONS" value="true" />
--      <option name="FORCE_STOP_RUNNING_APP" value="true" />
-+      <option name="INSPECTION_WITHOUT_ACTIVITY_RESTART" value="false" />
-       <option name="TARGET_SELECTION_MODE" value="EMULATOR" />
--      <option name="USE_LAST_SELECTED_DEVICE" value="false" />
--      <option name="PREFERRED_AVD" value="" />
-       <option name="DEBUGGER_TYPE" value="Java" />
-       <Java />
-       <Profilers>
-         <option name="ADVANCED_PROFILING_ENABLED" value="false" />
-+        <option name="STARTUP_PROFILING_ENABLED" value="false" />
-         <option name="STARTUP_CPU_PROFILING_ENABLED" value="false" />
-         <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME" value="Sample Java Methods" />
-+        <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED" value="false" />
-+        <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES" value="2048" />
-       </Profilers>
-       <option name="DEEP_LINK" value="" />
-       <option name="ACTIVITY_CLASS" value="" />
--      <method v="2">
--        <option name="Android.Gradle.BeforeRunTask" enabled="true" />
--      </method>
-+      <option name="SEARCH_ACTIVITY_IN_GLOBAL_SCOPE" value="false" />
-+      <option name="SKIP_ACTIVITY_VALIDATION" value="false" />
-+      <method v="2" />
-     </configuration>
--    <configuration default="true" type="AndroidTestRunConfigurationType">
-+    <configuration default="true" type="AndroidTestRunConfigurationType" factoryName="Android Instrumented Tests">
-       <option name="TESTING_TYPE" value="0" />
--      <option name="INSTRUMENTATION_RUNNER_CLASS" value="" />
-       <option name="METHOD_NAME" value="" />
-       <option name="CLASS_NAME" value="" />
-       <option name="PACKAGE_NAME" value="" />
-+      <option name="INSTRUMENTATION_RUNNER_CLASS" value="" />
-       <option name="EXTRA_OPTIONS" value="" />
-+      <option name="INCLUDE_GRADLE_EXTRA_OPTIONS" value="true" />
-+      <option name="RETENTION_ENABLED" value="No" />
-+      <option name="RETENTION_MAX_SNAPSHOTS" value="2" />
-+      <option name="RETENTION_COMPRESS_SNAPSHOTS" value="false" />
-       <option name="CLEAR_LOGCAT" value="false" />
-       <option name="SHOW_LOGCAT_AUTOMATICALLY" value="true" />
--      <option name="SKIP_NOOP_APK_INSTALLATIONS" value="true" />
--      <option name="FORCE_STOP_RUNNING_APP" value="true" />
-+      <option name="INSPECTION_WITHOUT_ACTIVITY_RESTART" value="false" />
-       <option name="TARGET_SELECTION_MODE" value="EMULATOR" />
--      <option name="USE_LAST_SELECTED_DEVICE" value="false" />
--      <option name="PREFERRED_AVD" value="" />
-       <option name="DEBUGGER_TYPE" value="Java" />
-       <Java />
-       <Profilers>
-         <option name="ADVANCED_PROFILING_ENABLED" value="false" />
-+        <option name="STARTUP_PROFILING_ENABLED" value="false" />
-         <option name="STARTUP_CPU_PROFILING_ENABLED" value="false" />
-         <option name="STARTUP_CPU_PROFILING_CONFIGURATION_NAME" value="Sample Java Methods" />
-+        <option name="STARTUP_NATIVE_MEMORY_PROFILING_ENABLED" value="false" />
-+        <option name="NATIVE_MEMORY_SAMPLE_RATE_BYTES" value="2048" />
-       </Profilers>
--      <method v="2">
--        <option name="Make" enabled="true" />
--        <option name="Android.Gradle.BeforeRunTask" enabled="true" />
--      </method>
--    </configuration>
--    <configuration default="true" type="Applet">
--      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
-       <method v="2">
-         <option name="Make" enabled="true" />
-       </method>
-@@ -169,6 +162,7 @@
-       </list>
-     </recent_temporary>
-   </component>
-+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
-   <component name="SvnConfiguration">
-     <configuration />
-   </component>
-Index: .idea/vcs.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"VcsDirectoryMappings\">\n    <mapping directory=\"$PROJECT_DIR$/../../../..\" vcs=\"Git\" />\n  </component>\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/vcs.xml b/.idea/vcs.xml
---- a/.idea/vcs.xml	(revision 8d2d97a18f77e17c906c6f06e314308254d3014d)
-+++ b/.idea/vcs.xml	(date 1666709913009)
-@@ -1,6 +1,7 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="VcsDirectoryMappings">
--    <mapping directory="$PROJECT_DIR$/../../../.." vcs="Git" />
-+    <mapping directory="$USER_HOME$" vcs="Git" />
-+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-   </component>
- </project>
-\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]" date="1666790576002" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10/26/22, 9:22 AM [Default]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ /dev/null	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]" date="1666799151823" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10/26/22, 11:45 AM [Default]" />
-</changelist>
\ No newline at end of file
Index: .log/history.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>--[ 2022.10.25.10.58.10.674.0 ]--\nNewLogger: P04_Pathfinding\nVersion: 1.5\n--[ 2022.10.25.10.58.10.677.0 ]--\nInitTree:\n/src/algs4.jar\n/src/Coord.java\n/src/stdlib.jar\n/src/Walker.java\n/src/Terrain.java\n/src/Pathfinder.java\n/src/TerrainEditor.java\n/src/PathfinderVisualizer.java\n/src/InteractivePathfinderVisualizer.java\n/.git/info/exclude\n/.git/logs/refs/heads/main\n/.git/logs/refs/remotes/origin/HEAD\n/.git/logs/HEAD\n/.git/refs/heads/main\n/.git/refs/remotes/origin/HEAD\n/.git/hooks/update.sample\n/.git/hooks/pre-push.sample\n/.git/hooks/commit-msg.sample\n/.git/hooks/pre-commit.sample\n/.git/hooks/pre-rebase.sample\n/.git/hooks/post-update.sample\n/.git/hooks/pre-receive.sample\n/.git/hooks/applypatch-msg.sample\n/.git/hooks/pre-applypatch.sample\n/.git/hooks/pre-merge-commit.sample\n/.git/hooks/push-to-checkout.sample\n/.git/hooks/fsmonitor-watchman.sample\n/.git/hooks/prepare-commit-msg.sample\n/.git/objects/pack/pack-b4e0115436e87889784e14152f6d0d80dd73fe34.idx\n/.git/objects/pack/pack-b4e0115436e87889784e14152f6d0d80dd73fe34.pack\n/.git/HEAD\n/.git/index\n/.git/config\n/.git/description\n/.git/packed-refs\n/.idea/copyright/profiles_settings.xml\n/.idea/libraries/algs4.xml\n/.idea/libraries/stdlib.xml\n/.idea/.name\n/.idea/vcs.xml\n/.idea/misc.xml\n/.idea/modules.xml\n/.idea/compiler.xml\n/.idea/workspace.xml\n/.idea/uiDesigner.xml\n/tests/.donotlog\n/tests/png2emap.py\n/tests/ramp.png.emap\n/tests/ramp2.png.emap\n/tests/ramp3.png.emap\n/tests/mazeAB.png.emap\n/tests/usa128.png.emap\n/tests/usa256.png.emap\n/tests/usa1024.png.emap\n/tests/maze32_0.png.emap\n/tests/maze32_1.png.emap\n/tests/maze232_0.png.emap\n/tests/maze320_0.png.emap\n/tests/mazeBrain.png.emap\n/.cos265\n/readme.html\n/P04_Pathfinding.iml\n\n--[ 2022.10.25.10.58.10.678.0 ]--\nInitFile: /src/TerrainEditor.java\n/**\n * The following class provides some simple terrain editing functions.\n */\npublic class TerrainEditor {\n    private static float rndRadius(float d) {\n        return (float)StdRandom.uniform(-d,d);\n    }\n\n    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {\n        int N = terrain.getN();\n        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range\n        if(!isset[i + j * N]) {\n            isset[i + j * N] = true;\n            terrain.setHeight(i, j, dh);\n        }\n        return terrain.getHeight(i,j);\n    }\n\n    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {\n        int id = i1-i0;\n        int jd = j1-j0;\n        int i01 = (i0+i1)/2;\n        int j01 = (j0+j1)/2;\n\n        if(id <= 1 && jd <= 1) return;\n\n        float h00 = getFractalHeight(i0,j0,32,terrain,isset);\n        float h01 = getFractalHeight(i0,j1,32,terrain,isset);\n        float h10 = getFractalHeight(i1,j0,32,terrain,isset);\n        float h11 = getFractalHeight(i1,j1,32,terrain,isset);\n\n        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);\n\n        float d0001 = (h00 + h01) / 2 + rndRadius(d);\n        float d0010 = (h00 + h10) / 2 + rndRadius(d);\n        float d1101 = (h11 + h01) / 2 + rndRadius(d);\n        float d1110 = (h11 + h10) / 2 + rndRadius(d);\n\n        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);\n        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);\n        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);\n        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);\n\n        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);\n        float hm = getFractalHeight(i01, j01, dm, terrain,isset);\n\n        if(id > 1 && jd > 1) {\n            setFractalHeights(i0, j0, i01, j01, terrain, isset);\n            setFractalHeights(i01, j0, i1, j01, terrain, isset);\n            setFractalHeights(i0, j01, i01, j1, terrain, isset);\n            setFractalHeights(i01, j01, i1, j1, terrain, isset);\n        } else if(jd > 1) {\n            setFractalHeights(i0, j0, i1, j01, terrain, isset);\n            setFractalHeights(i0, j01, i1, j1, terrain, isset);\n        } else {\n            setFractalHeights(i0, j0, i01, j1, terrain, isset);\n            setFractalHeights(i01, j0, i1, j1, terrain, isset);\n        }\n    }\n\n    public static void setFractalHeights(Terrain terrain) {\n        int N = terrain.getN();\n        boolean[] isset = new boolean[N*N];\n        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);\n    }\n\n    public static void smoothHeights(Terrain terrain) {\n        int N = terrain.getN();\n        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));\n        smoothHeights(N/2, N/2, radius, false, terrain);\n    }\n\n    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {\n        final int N = terrain.getN();\n        final int w = 2*radius+1;\n        float[] s = new float[w*w];\n        for(int ia = -radius; ia <= radius; ia++) {\n            int i = ic + ia;\n            if(i < 0 || i >= N) continue;\n            for(int ja = -radius; ja <= radius; ja++) {\n                int j = jc + ja;\n                if(j < 0 || j >= N) continue;\n                int sidx = (ia+radius) + (ja+radius)*w;\n\n                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);\n                if(m <= 0.0000001) {\n                    s[sidx] = terrain.getHeight(i,j);\n                    continue;\n                }\n                float h = 0;\n                int c = 0;\n                if(i > 0 && j > 0) {\n                    h += terrain.getHeight(i-1,j-1);\n                    c += 1;\n                }\n                if(i < N-1 && j > 0) {\n                    h += terrain.getHeight(i+1,j-1);\n                    c += 1;\n                }\n                if(i > 0 && j < N-1) {\n                    h += terrain.getHeight(i-1,j+1);\n                    c += 1;\n                }\n                if(i < N-1 && j < N-1) {\n                    h += terrain.getHeight(i+1,j+1);\n                    c += 1;\n                }\n                if(i > 0) {\n                    h += terrain.getHeight(i-1,j);\n                    c += 1;\n                }\n                if(j > 0) {\n                    h += terrain.getHeight(i,j-1);\n                    c += 1;\n                }\n                if(i < N-1) {\n                    h += terrain.getHeight(i+1,j);\n                    c += 1;\n                }\n                if(j < N-1) {\n                    h += terrain.getHeight(i,j+1);\n                    c += 1;\n                }\n                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;\n            }\n        }\n        for(int ia = -radius; ia <= radius; ia++) {\n            int i = ic + ia;\n            if(i < 0 || i >= N) continue;\n            for(int ja = -radius; ja <= radius; ja++) {\n                int j = jc + ja;\n                if(j < 0 || j >= N) continue;\n                int sidx = (ia+radius) + (ja+radius)*w;\n                terrain.setHeight(i, j, s[sidx]);\n            }\n        }\n    }\n\n    public static void clampHeights(Terrain terrain) {\n        int N = terrain.getN();\n        for(int i = 0; i < N; i++) {\n            for(int j = 0; j < N; j++) {\n                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));\n            }\n        }\n    }\n\n    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {\n        if(i < 0 || j < 0 || i >= N || j >= N) return 0;\n        if(!fallOff) return 1;\n        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);\n        if(d2 > radius*radius) return 0;\n        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;\n    }\n\n    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {\n        final int N = terrain.getN();\n        for(int ja = -radius; ja <= radius; ja++) {\n            int r = j + ja;\n            if(r < 0 || r >= N) continue;\n            for(int ia = -radius; ia <= radius; ia++) {\n                int c = i + ia;\n                if(c < 0 || c >= N) continue;\n                float v = add * computeEffect(c, r, i, j, radius, true, N);\n                float h = terrain.getHeight(c, r) + v;\n                h = Math.max(0, Math.min(255, h));\n                terrain.setHeight(c, r, h);\n            }\n        }\n    }\n}\n\n--[ 2022.10.25.10.58.10.678.1 ]--\nInitFile: /src/InteractivePathfinderVisualizer.java\nimport java.awt.event.KeyEvent;\n\n/**\n * InteractivePathfinderVisualizer visualizes the terrain and the computed\n * path and allows the user to change parameters of the Pathfinder.  Below\n * is a list of commands and what they do.  Note: some of the commands\n * modify the properties of the path finder and some modify the terrain.\n *\n * Command        Action                                      Terrain\n * C              clear path\n * space          recompute path\n * S/E            set start/end location to mouse\n * left/right     halve/double path search heuristic value\n * 0/1            set path search heuristic to 0 or 1\n * W              start a walker to show the path\n * R              randomly generate a new terrain                *\n * M              smooths terrain under mouse                    *\n * shift+M        smooths all terrain                            *\n * up/down        increase/decrease terrain under mouse          *\n */\n\npublic class InteractivePathfinderVisualizer {\n    private final static int DELAY = 10;\n\n    // sets how many redraws it should take for the walker to reach its destination\n    private final static float STEPS_TO_WALK = 100.0f;\n\n    // for convenience, here are the emap files that are located under heightmaps/ folder\n    // the python script in that folder converts png files to emap. \\\n    // you can use it to create your own maps to test your code\n    private final static String[] emaps = {\n            \"maze32_0.png.emap\",    // 0   (32x32 maze)\n            \"maze32_1.png.emap\",    // 1   (another 32x32 maze)\n            \"maze232_0.png.emap\",   // 2   (232x232 maze)\n            \"maze320_0.png.emap\",   // 3   (same as maze32_0, only scaled up by 10x)\n            \"mazeAB.png.emap\",      // 4   (a maze from a site no longer online :( )\n            \"mazeBrain.png.emap\",   // 5   (...)\n            \"ramp.png.emap\",        // 6   (some tests)\n            \"ramp2.png.emap\",       // 7   (...)\n            \"ramp3.png.emap\",       // 8   (...)\n            \"usa128.png.emap\",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)\n            \"usa256.png.emap\",      // 10  (same as usa128, only higher resolution)\n            \"usa1024.png.emap\",     // 11  (same as usa128, only higher resolution\n    };\n\n    private final static String emapFilename = emaps[2];        // change index to load a different elevation map\n\n\n\n    public static void main(String[] args) {\n        Terrain terrain = new Terrain(emapFilename);\n        Pathfinder pf = new Pathfinder(terrain);\n        int N = terrain.getN();\n\n        StdDraw.show(0);\n\n        // set default starting and ending locations\n        pf.setPathStart(new Coord(1, 1));\n        pf.setPathEnd(new Coord(N-3, N-3));\n\n        // find a path\n        pf.resetPath();\n        pf.computePath();\n\n        PathfinderVisualizer.draw(terrain, pf, null, N);\n        StdDraw.show(DELAY);\n\n        // prevent repeated applications\n        boolean keyboardR = false;\n        boolean keyboardM = false;\n\n        Walker walker = null;\n\n        while(true) {\n            boolean recompute = false;\n            boolean redraw = false;\n\n            // mouse location on map\n            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);\n            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);\n            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {\n                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);\n                float m = keyboardLeft ? 0.5f : 2.0f;\n                float h = pf.getHeuristic() * m;\n                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));\n                pf.setHeuristic(h);\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {\n                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);\n                float h = keyboard0 ? 0 : 1;\n                pf.setHeuristic(h);\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {\n                pf.resetPath();\n                walker = null;\n                redraw = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {\n                TerrainEditor.setFractalHeights(terrain);\n                TerrainEditor.clampHeights(terrain);\n                recompute = true;\n            }\n            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {\n                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {\n                    if(!keyboardM) {\n                        TerrainEditor.smoothHeights(terrain);\n                        recompute = true;\n                    }\n                } else {\n                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);\n                    recompute = true;\n                }\n            }\n            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {\n                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);\n                float add = keyboardUp ? 8.0f : -8.0f;\n                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);\n                recompute = true;\n            }\n\n            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {\n                pf.setPathStart(new Coord(mouseI, mouseJ));\n                recompute = true;\n            }\n\n            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {\n                pf.setPathEnd(new Coord(mouseI, mouseJ));\n                recompute = true;\n            }\n\n            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {\n                Iterable<Coord> path = pf.getPathSolution();\n                if(path != null) {\n                    walker = new Walker(terrain, pf.getPathSolution());\n                }\n            }\n\n            if(walker != null) {\n                if(walker.doneWalking()) {\n                    walker = null;\n                } else {\n                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);\n                }\n                redraw = true;\n            }\n\n            if(recompute) {\n                walker = null;\n                pf.resetPath();\n                if(pf.getPathStart() != null && pf.getPathEnd() != null) {\n                    pf.computePath();\n                }\n                redraw = true;\n            }\n\n            if(redraw) {\n                PathfinderVisualizer.draw(terrain, pf, walker, N);\n                StdDraw.show(DELAY);\n            } else {\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    /* do nothing */\n                }\n            }\n        }\n    }\n}\n\n--[ 2022.10.25.10.58.10.678.2 ]--\nInitFile: /src/PathfinderVisualizer.java\n/**\n * PathfinderVisualizer visualizes the terrain and found path.\n */\n\nimport java.awt.Color;\nimport java.awt.Font;\n\npublic class PathfinderVisualizer {\n\n    // delay in milliseconds (controls animation speed)\n    private final static int DELAY = 100;\n\n    // color for different elevations.  must be in ascending order!\n    private final static int[][] elevationColors = {\n            // h    r   g   b   where h=height, r=red, g=green, b=blue\n            {  0,   0,  0,  0},\n            {  2,   0,  0,160},\n            {  4,   0,224,224},\n            { 16, 192,192,  0},\n            { 64,  16,255, 16},\n            {128,  32,224, 32},\n            {192, 128,128,  8},\n            {224, 164,164,164},\n            {255, 255,255,255}\n    };\n\n    private final static Color cStart    = new Color(128, 128, 255);\n    private final static Color cEnd      = new Color(255, 128, 128);\n    private final static Color cSolution = new Color(255, 128, 255);\n    private final static Color cSearched = new Color(128,   0, 128);\n\n    // linearly interpolating between the corresponding rgb values\n    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {\n        v1 = Math.max(0.0f, Math.min(1.0f, v1));\n        float v0 = 1.0f - v1;\n        int r = (int)(v0 * r0 + v1 * r1);\n        int g = (int)(v0 * g0 + v1 * g1);\n        int b = (int)(v0 * b0 + v1 * b1);\n        return new Color(r, g, b);\n    }\n    private static Color colorLERP(float v1, Color c0, Color c1) {\n        v1 = Math.max(0.0f, Math.min(1.0f, v1));\n        float v0 = 1.0f - v1;\n        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());\n        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());\n        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());\n        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());\n        return new Color(r, g, b, a);\n    }\n\n    // returns color for given height\n    private static Color height2Color(int h) {\n        h = Math.max(0, Math.min(255, h));\n\n        int[] ec0 = elevationColors[0];  // default lower bound\n        int[] ec1 = elevationColors[1];  // default upper bound\n\n        // find upper bound while updating lower bound\n        for(int i = 1; i < elevationColors.length; i++) {\n            ec1 = elevationColors[i];\n            if(h >= ec0[0] && h <= ec1[0]) break;\n            ec0 = ec1;\n        }\n\n        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];\n        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];\n        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));\n\n        return colorLERP(v1, r0, g0, b0, r1, g1, b1);\n    }\n\n    private static void drawCircle(int i, int j, int N, double rad) {\n        int c = (int)((i+0.5f) * 464.0f / N);\n        int r = (int)((j+0.5f) * 464.0f / N);\n        StdDraw.circle(c + 24, 464 - r + 36, rad);\n    }\n    public static void drawCircle(Coord loc, int N, double rad) {\n        drawCircle(loc.getI(), loc.getJ(), N, rad);\n    }\n\n    private static void drawPath(Iterable<Coord> path, int N) {\n        boolean first = true;\n        int c0 = 0, r0 = 0;\n        for (Coord loc : path) {\n            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);\n            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);\n            if(!first) {\n                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);\n            }\n            first = false;\n            c0 = c1; r0 = r1;\n        }\n    }\n\n    // draw N-by-N pathfinding map\n    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {\n        StdDraw.clear();\n        StdDraw.setXscale(0, 512);\n        StdDraw.setYscale(0, 512);\n        StdDraw.setPenColor(StdDraw.BLACK);\n        StdDraw.filledSquare(256, 256 + 12, 464 / 2);\n\n        // draw terrain\n        for(int row = 0; row < 464; row++) {\n            int j = (int)((float)row/464.0f * N);\n            for(int col = 0; col < 464; col++) {\n                int i = (int)((float)col/464.0f * N);\n                Coord loc = new Coord(i,j);\n                Color c = height2Color(terrain.getHeight(loc));\n                if(pf.wasSearched(loc)) {\n                    c = colorLERP(0.50f, c, cSearched);\n                }\n                StdDraw.setPenColor(c);\n                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);\n            }\n        }\n\n        // draw path start\n        if(pf.getPathStart() != null) {\n            StdDraw.setPenColor(StdDraw.BLACK);\n            StdDraw.setPenRadius(0.006);\n            drawCircle(pf.getPathStart(), N, 4.0);\n\n            StdDraw.setPenColor(cStart);\n            StdDraw.setPenRadius(0.002);\n            drawCircle(pf.getPathStart(), N, 4.0);\n        }\n\n        // draw path end\n        if(pf.getPathEnd() != null) {\n            StdDraw.setPenColor(StdDraw.BLACK);\n            StdDraw.setPenRadius(0.006);\n            drawCircle(pf.getPathEnd(), N, 4.0);\n\n            StdDraw.setPenColor(cEnd);\n            StdDraw.setPenRadius(0.002);\n            drawCircle(pf.getPathEnd(), N, 4.0);\n        }\n\n        // draw found path\n        if(pf.foundPath()) {\n            StdDraw.setPenColor(StdDraw.BLACK);\n            StdDraw.setPenRadius(0.006);\n            drawPath(pf.getPathSolution(), N);\n\n            StdDraw.setPenColor(cSolution);\n            StdDraw.setPenRadius(0.002);\n            drawPath(pf.getPathSolution(), N);\n        }\n\n        // draw walker\n        if(walker != null) {\n            Coord loc = walker.getLocation();\n            StdDraw.setPenColor(StdDraw.BLACK);\n            StdDraw.setPenRadius(0.006);\n            PathfinderVisualizer.drawCircle(loc, N, 2.0);\n\n            StdDraw.setPenColor(StdDraw.WHITE);\n            StdDraw.setPenRadius(0.002);\n            PathfinderVisualizer.drawCircle(loc, N, 2.0);\n        }\n\n        // write status text\n        StdDraw.setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n        StdDraw.setPenColor(StdDraw.BLACK);\n        StdDraw.text(96, 12, \"heuristic: \" + pf.getHeuristic());\n        if(pf.foundPath()) StdDraw.text(256, 12, \"path: \" + pf.getPathCost());\n        else               StdDraw.text(256, 12, \"no path found\");\n        StdDraw.text(512-96, 12, \"searched: \" + pf.getSearchSize() + \" (\" + (int)(100.0f * pf.getSearchSize() / (N*N)) + \"%)\");\n    }\n}\n\n--[ 2022.10.25.10.58.10.678.3 ]--\nInitFile: /src/Pathfinder.java\nimport java.lang.IndexOutOfBoundsException;\nimport java.lang.IllegalArgumentException;\n\n/**\n * Pathfinder uses A* search to find a near optimal path\n * between to locations with given terrain.\n */\n\npublic class Pathfinder {\n\n    /**\n     * PFNode will be the key for MinPQ (used in computePath())\n     */\n    private class PFNode implements Comparable<PFNode> {\n        // loc: the location of the PFNode\n        // fromNode: how did we get here? (linked list back to start)\n        public PFNode(Coord loc, PFNode fromNode) { }\n\n        // compares this with that, used to find minimum cost PFNode\n        public int compareTo(PFNode that) {\n            return 0;\n        }\n\n        // returns the cost to travel from starting point to this\n        // via the fromNode chain\n        public float getCost(float heuristic) {\n            return 0;\n        }\n\n        // returns if this PFNode is still valid\n        public boolean isValid() {\n            return false;\n        }\n\n        // invalidates the PFNode\n        public void invalidate() {\n        }\n\n        // returns if the PFNode has been used\n        public boolean isUsed() {\n            return true;\n        }\n\n        // uses the PFNode\n        public void use() { }\n\n        // returns an Iterable of PFNodes that surround this\n        public Iterable<PFNode> neighbors() {\n            Stack<PFNode> s = new Stack<>();\n            s.push(new PFNode(null, null));\n            return s;\n        }\n    }\n\n    public Pathfinder(Terrain terrain) {\n    }\n\n    public void setPathStart(Coord loc) {\n    }\n\n    public Coord getPathStart() {\n        return null;\n    }\n\n    public void setPathEnd(Coord loc) {\n    }\n\n    public Coord getPathEnd() {\n        return null;\n    }\n\n    public void setHeuristic(float v) {\n    }\n\n    public float getHeuristic() {\n        return 0;\n    }\n\n    public void resetPath() {\n    }\n\n    public void computePath() {\n    }\n\n    public boolean foundPath() {\n        return false;\n    }\n\n    public float getPathCost() {\n        return 0;\n    }\n\n    public int getSearchSize() {\n        return 0;\n    }\n\n    public Iterable<Coord> getPathSolution() {\n        return null;\n    }\n\n    public boolean wasSearched(Coord loc) {\n        return false;\n    }\n}\n\n--[ 2022.10.25.10.58.10.678.4 ]--\nInitFile: /.cos265\n\n\n--[ 2022.10.25.10.58.10.678.5 ]--\nInitFile: /src/Coord.java\n/**\n * Coordinates is an immutable type that store the tuple (i, j)\n */\npublic final class Coord {\n    private final int i;\n    private final int j;\n\n    public Coord(int i, int j) {\n        this.i = i;\n        this.j = j;\n    }\n\n    public int getI() { return i; }\n    public int getJ() { return j; }\n\n    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {\n        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;\n    }\n    public boolean isInBounds(Coord min, Coord max) {\n        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;\n    }\n\n    public Coord add(int addI, int addJ) {\n        return new Coord(i + addI, j + addJ);\n    }\n    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }\n\n    public String toString() { return \"(\" + i + \",\" + j + \")\"; }\n\n    public boolean equals(Object o) {\n        if(this == o) return true;\n        if(o == null) return false;\n        if(o.getClass() != this.getClass()) return false;\n        Coord that = (Coord) o;\n        if(this.i != that.i) return false;\n        if(this.j != that.j) return false;\n        return true;\n    }\n}\n\n--[ 2022.10.25.10.58.10.678.6 ]--\nInitFile: /P04_Pathfinding.iml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\">\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\n      <sourceFolder url=\"file://$MODULE_DIR$/tests\" type=\"java-resource\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/.log\" />\n    </content>\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n    <orderEntry type=\"library\" name=\"algs4\" level=\"project\" />\n    <orderEntry type=\"library\" name=\"stdlib\" level=\"project\" />\n  </component>\n</module>\n\n--[ 2022.10.25.10.58.10.678.7 ]--\nInitFile: /src/Walker.java\nimport java.util.Iterator;\n\n/**\n * Walker takes an Iterable of Coords and simulates an individual\n * walking along the path over the given Terrain\n */\npublic class Walker {\n\n    // terrain: the Terrain the Walker traverses\n    // path: the sequence of Coords the Walker follows\n    public Walker(Terrain terrain, Iterable<Coord> path) {\n    }\n\n    // returns the Walker's current location\n    public Coord getLocation() {\n        return null;\n    }\n\n    // returns true if Walker has reached the end Coord (last in path)\n    public boolean doneWalking() {\n        return true;\n    }\n\n    // advances the Walker along path\n    // byTime: how long the Walker should traverse (may be any non-negative value)\n    public void advance(float byTime) {\n    }\n\n}\n\n--[ 2022.10.25.10.58.10.678.8 ]--\nInitFile: /src/Terrain.java\nimport java.lang.IndexOutOfBoundsException;\n\n/**\n * Terrain stores elevations for map and computes distance and\n * cost in traversing the terrain.\n */\n\npublic class Terrain {\n    private int N;\n    private int[][] heights;\n\n    public Terrain(int N) {\n        this.N = N;\n        this.heights = new int[N][N];\n    }\n\n    public Terrain(int[][] heights) {\n        this.N = heights.length;\n        this.heights = heights;\n    }\n\n    public Terrain(String emapfile) {\n        In in = new In(emapfile);\n        this.N = in.readInt();\n        this.heights = new int[N][N];\n        for (int j = 0; j < N; j++) {\n            for (int i = 0; i < N; i++) {\n                this.heights[i][j] = in.readInt();\n            }\n        }\n    }\n\n    public int getN() {\n        return N;\n    }\n\n    public void setHeight(int i, int j, int h) {\n        if(i < 0 || j < 0 || i >= N || j >= N)\n            throw new IndexOutOfBoundsException(\"i and j must be in [0,N)\");\n        heights[i][j] = h;\n    }\n    public void setHeight(int i, int j, float h) {\n        setHeight(i, j, (int) h);\n    }\n    public void setHeight(Coord loc, int h) {\n        setHeight(loc.getI(), loc.getJ(), h);\n    }\n    public void setHeight(Coord loc, float h) {\n        setHeight(loc.getI(), loc.getJ(), h);\n    }\n\n    public int getHeight(int i, int j) {\n        if(i < 0 || j < 0 || i >= N || j >= N)\n            throw new IndexOutOfBoundsException(\"i and j must be in [0,N)\");\n        return heights[i][j];\n    }\n    public int getHeight(Coord loc) {\n        return getHeight(loc.getI(), loc.getJ());\n    }\n\n    // computes distance between (i0,j0) and (i1,j1) as the crow flies\n    public float computeDistance(int i0, int j0, int i1, int j1) {\n        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));\n    }\n    public float computeDistance(Coord c0, Coord c1) {\n        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());\n    }\n\n    public float computeTravelCost(int i0, int j0, int i1, int j1) {\n        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);\n        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);\n        float dist = computeDistance(i0,j0, i1,j1);\n        return (1.0f + climb) * dist;\n    }\n    public float computeTravelCost(Coord c0, Coord c1) {\n        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());\n    }\n    public float computeTravelCost(Iterable<Coord> cs) {\n        Coord c0 = null;\n        float cost = 0.0f;\n        for(Coord c1 : cs) {\n            if(c0 != null) cost += computeTravelCost(c0, c1);\n            c0 = c1;\n        }\n        return cost;\n    }\n}\n\n--[ 2022.10.25.10.58.11.757.0 ]--\nUpdateTree (AD): 1 0\n+ /.log/history.log\n\n--[ 2022.10.25.11.00.30.352.0 ]--\n:/src/InteractivePathfinderVisualizer.java\nr 2 /\n--[ 2022.10.25.11.00.30.373.0 ]--\nr 2 //\n--[ 2022.10.25.11.00.36.681.0 ]--\nr 2 //h\n--[ 2022.10.25.11.00.36.733.0 ]--\nr 2 //hi\n--[ 2022.10.25.11.00.37.916.0 ]--\nr 2 //h\n--[ 2022.10.25.11.00.37.941.0 ]--\nr 2 //\n--[ 2022.10.25.11.00.38.099.0 ]--\nr 2 /\n--[ 2022.10.25.11.00.38.788.0 ]--\nr 2 //\n--[ 2022.10.25.11.00.39.131.0 ]--\nr 2 //k\n--[ 2022.10.25.11.00.39.224.0 ]--\nr 2 //ka\n--[ 2022.10.25.11.00.39.344.0 ]--\nr 2 //kat\n--[ 2022.10.25.11.00.39.469.0 ]--\nr 2 //kate\n--[ 2022.10.25.11.00.39.650.0 ]--\nr 2 //kate \n--[ 2022.10.25.11.00.39.776.0 ]--\nr 2 //kate w\n--[ 2022.10.25.11.00.39.950.0 ]--\nr 2 //kate wa\n--[ 2022.10.25.11.00.40.027.0 ]--\nr 2 //kate was\n--[ 2022.10.25.11.00.40.150.0 ]--\nr 2 //kate was \n--[ 2022.10.25.11.00.40.330.0 ]--\nr 2 //kate was h\n--[ 2022.10.25.11.00.40.394.0 ]--\nr 2 //kate was he\n--[ 2022.10.25.11.00.40.468.0 ]--\nr 2 //kate was her\n--[ 2022.10.25.11.00.40.593.0 ]--\nr 2 //kate was here\n--[ 2022.10.25.11.17.56.519.0 ]--\nUpdateTree (AD): 24 0\n+ /out/production/P04_Pathfinding/.donotlog\n+ /out/production/P04_Pathfinding/algs4.jar\n+ /out/production/P04_Pathfinding/stdlib.jar\n+ /out/production/P04_Pathfinding/Coord.class\n+ /out/production/P04_Pathfinding/png2emap.py\n+ /out/production/P04_Pathfinding/Walker.class\n+ /out/production/P04_Pathfinding/ramp.png.emap\n+ /out/production/P04_Pathfinding/Terrain.class\n+ /out/production/P04_Pathfinding/ramp2.png.emap\n+ /out/production/P04_Pathfinding/ramp3.png.emap\n+ /out/production/P04_Pathfinding/mazeAB.png.emap\n+ /out/production/P04_Pathfinding/usa128.png.emap\n+ /out/production/P04_Pathfinding/usa256.png.emap\n+ /out/production/P04_Pathfinding/Pathfinder.class\n+ /out/production/P04_Pathfinding/usa1024.png.emap\n+ /out/production/P04_Pathfinding/maze32_0.png.emap\n+ /out/production/P04_Pathfinding/maze32_1.png.emap\n+ /out/production/P04_Pathfinding/maze232_0.png.emap\n+ /out/production/P04_Pathfinding/maze320_0.png.emap\n+ /out/production/P04_Pathfinding/mazeBrain.png.emap\n+ /out/production/P04_Pathfinding/TerrainEditor.class\n+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class\n+ /out/production/P04_Pathfinding/PathfinderVisualizer.class\n+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class\n\n--[ 2022.10.25.11.17.56.520.0 ]--\nCompilationStatus (AEW): 0 0 0\n--[ 2022.10.25.11.24.54.676.0 ]--\nCompilationStatus (AEW): 0 0 0\n--[ 2022.10.25.11.29.27.965.0 ]--\n:/src/Pathfinder.java\n+ 17         public PFNode(Coord loc, PFNode fromNode) { \nr 18         }\n--[ 2022.10.25.11.29.28.011.0 ]--\n+ 18             \n--[ 2022.10.25.11.29.30.973.0 ]--\n+ 17         \n--[ 2022.10.25.11.29.32.878.0 ]--\n- 17\n--[ 2022.10.25.11.29.34.768.0 ]--\n- 17\nr 17         public PFNode(Coord loc, PFNode fromNode) {\n--[ 2022.10.25.11.29.59.888.0 ]--\n+ 17         \n--[ 2022.10.25.11.30.02.364.0 ]--\nr 17         C\n--[ 2022.10.25.11.30.02.644.0 ]--\nr 17         Co\n--[ 2022.10.25.11.30.02.691.0 ]--\nr 17         Coo\n--[ 2022.10.25.11.30.02.786.0 ]--\nr 17         Coor\n--[ 2022.10.25.11.30.02.988.0 ]--\nr 17         Coord\n--[ 2022.10.25.11.30.03.364.0 ]--\nr 17         Coord \n--[ 2022.10.25.11.30.03.488.0 ]--\nr 17         Coord l\n--[ 2022.10.25.11.30.03.681.0 ]--\nr 17         Coord lo\n--[ 2022.10.25.11.30.04.149.0 ]--\nr 17         Coord loc\n--[ 2022.10.25.11.30.04.807.0 ]--\nr 17         Coord loc;\n--[ 2022.10.25.11.30.08.539.0 ]--\n+ 19             \n--[ 2022.10.25.11.30.09.349.0 ]--\nr 19             l\n--[ 2022.10.25.11.30.09.509.0 ]--\nr 19             lo\n--[ 2022.10.25.11.30.09.631.0 ]--\nr 19             loc\n--[ 2022.10.25.11.30.09.895.0 ]--\nr 19             loc \n--[ 2022.10.25.11.30.10.260.0 ]--\nr 19             loc =\n--[ 2022.10.25.11.30.10.350.0 ]--\nr 19             loc = \n--[ 2022.10.25.11.30.10.556.0 ]--\nr 19             loc = l\n--[ 2022.10.25.11.30.10.733.0 ]--\nr 19             loc = lo\n--[ 2022.10.25.11.30.10.798.0 ]--\nr 19             loc = loc\n--[ 2022.10.25.11.30.11.404.0 ]--\nr 19             loc = loc;\n--[ 2022.10.25.11.30.32.407.0 ]--\n- 19\n--[ 2022.10.25.11.30.34.097.0 ]--\n- 17\n--[ 2022.10.25.11.32.14.657.0 ]--\n+ 22             \n--[ 2022.10.25.11.32.19.516.0 ]--\nr 22             r\n--[ 2022.10.25.11.32.19.662.0 ]--\nr 22             re\n--[ 2022.10.25.11.32.20.329.0 ]--\nr 22             ret\n--[ 2022.10.25.11.32.20.720.0 ]--\nr 22             retu\n--[ 2022.10.25.11.32.21.013.0 ]--\nr 22             retun\n--[ 2022.10.25.11.32.21.058.0 ]--\nr 22             retunr\n--[ 2022.10.25.11.32.21.406.0 ]--\nr 22             retunr \n--[ 2022.10.25.11.32.21.779.0 ]--\nr 22             retunr\n--[ 2022.10.25.11.32.21.954.0 ]--\nr 22             retun\n--[ 2022.10.25.11.32.22.160.0 ]--\nr 22             retu\n--[ 2022.10.25.11.32.22.681.0 ]--\nr 22             retur\n--[ 2022.10.25.11.32.22.835.0 ]--\nr 22             return\n--[ 2022.10.25.11.32.23.026.0 ]--\nr 22             return \n--[ 2022.10.25.11.32.24.936.0 ]--\nr 22             return t\n--[ 2022.10.25.11.32.25.075.0 ]--\nr 22             return th\n--[ 2022.10.25.11.32.25.231.0 ]--\nr 22             return thi\n--[ 2022.10.25.11.32.25.466.0 ]--\nr 22             return this\n--[ 2022.10.25.11.32.25.707.0 ]--\nr 22             return this.\n--[ 2022.10.25.11.32.26.034.0 ]--\nr 22             return this.c\n--[ 2022.10.25.11.32.26.114.0 ]--\nr 22             return this.co\n--[ 2022.10.25.11.32.26.302.0 ]--\nr 22             return this.com\n--[ 2022.10.25.11.32.26.498.0 ]--\nr 22             return this.compareTo\n--[ 2022.10.25.11.32.26.508.0 ]--\nr 22             return this.compareTo()\n--[ 2022.10.25.11.32.27.120.0 ]--\nr 22             return this.compareTo(t)\n--[ 2022.10.25.11.32.27.403.0 ]--\nr 22             return this.compareTo(th)\n--[ 2022.10.25.11.32.27.515.0 ]--\nr 22             return this.compareTo(tha)\n--[ 2022.10.25.11.32.27.597.0 ]--\nr 22             return this.compareTo(that)\n--[ 2022.10.25.11.32.28.716.0 ]--\nr 22             return this.compareTo(that);\n--[ 2022.10.25.11.32.30.554.0 ]--\nr 23             \n--[ 2022.10.25.11.32.41.821.0 ]--\n- 23\n--[ 2022.10.25.11.32.43.491.0 ]--\nr 22             return this.compareTo(that);    \n--[ 2022.10.25.11.32.43.628.0 ]--\nr 22             return this.compareTo(that);        \n--[ 2022.10.25.11.32.43.820.0 ]--\nr 22             return this.compareTo(that);        /\n--[ 2022.10.25.11.32.43.984.0 ]--\nr 22             return this.compareTo(that);        //\n--[ 2022.10.25.11.32.44.509.0 ]--\nr 22             return this.compareTo(that);        //?\n--[ 2022.10.25.11.32.44.681.0 ]--\nr 22             return this.compareTo(that);        //??\n--[ 2022.10.25.11.32.44.830.0 ]--\nr 22             return this.compareTo(that);        //???\n--[ 2022.10.25.11.38.03.379.0 ]--\n+ 60         \n--[ 2022.10.25.11.38.24.944.0 ]--\nr 58     \n--[ 2022.10.25.11.38.28.243.0 ]--\nr 58     C\n--[ 2022.10.25.11.38.28.624.0 ]--\nr 58     Co\n--[ 2022.10.25.11.38.28.788.0 ]--\nr 58     Coo\n--[ 2022.10.25.11.38.28.891.0 ]--\nr 58     Coor\n--[ 2022.10.25.11.38.29.194.0 ]--\nr 58     Coord\n--[ 2022.10.25.11.38.29.504.0 ]--\nr 58     Coord \n--[ 2022.10.25.11.38.30.101.0 ]--\nr 58     Coord p\n--[ 2022.10.25.11.38.30.190.0 ]--\nr 58     Coord pa\n--[ 2022.10.25.11.38.30.320.0 ]--\nr 58     Coord pat\n--[ 2022.10.25.11.38.30.392.0 ]--\nr 58     Coord path\n--[ 2022.10.25.11.38.30.725.0 ]--\nr 58     Coord paths\n--[ 2022.10.25.11.38.31.398.0 ]--\nr 58     Coord path\n--[ 2022.10.25.11.38.31.786.0 ]--\nr 58     Coord pathS\n--[ 2022.10.25.11.38.32.000.0 ]--\nr 58     Coord pathSt\n--[ 2022.10.25.11.38.32.178.0 ]--\nr 58     Coord pathSta\n--[ 2022.10.25.11.38.32.247.0 ]--\nr 58     Coord pathStar\n--[ 2022.10.25.11.38.32.408.0 ]--\nr 58     Coord pathStart\n--[ 2022.10.25.11.38.35.026.0 ]--\nr 58     Coord pathStart;\n--[ 2022.10.25.11.38.35.860.0 ]--\nr 58     Coord pathStart;    \n--[ 2022.10.25.11.38.37.529.0 ]--\nr 60         p\n--[ 2022.10.25.11.38.37.649.0 ]--\nr 60         pa\n--[ 2022.10.25.11.38.37.790.0 ]--\nr 60         pat\n--[ 2022.10.25.11.38.37.929.0 ]--\nr 60         path\n--[ 2022.10.25.11.38.38.364.0 ]--\nr 60         pathS\n--[ 2022.10.25.11.38.38.535.0 ]--\nr 60         pathSt\n--[ 2022.10.25.11.38.38.665.0 ]--\nr 60         pathSta\n--[ 2022.10.25.11.38.38.757.0 ]--\nr 60         pathStar\n--[ 2022.10.25.11.38.38.930.0 ]--\nr 60         pathStart\n--[ 2022.10.25.11.38.39.268.0 ]--\nr 60         pathStart \n--[ 2022.10.25.11.38.39.610.0 ]--\nr 60         pathStart =\n--[ 2022.10.25.11.38.39.723.0 ]--\nr 60         pathStart = \n--[ 2022.10.25.11.38.40.248.0 ]--\nr 60         pathStart = l\n--[ 2022.10.25.11.38.40.430.0 ]--\nr 60         pathStart = lo\n--[ 2022.10.25.11.38.40.576.0 ]--\nr 60         pathStart = loc\n--[ 2022.10.25.11.38.40.948.0 ]--\nr 60         pathStart = loc;\n--[ 2022.10.25.11.38.51.931.0 ]--\nr 64         return p;\n--[ 2022.10.25.11.38.52.019.0 ]--\nr 64         return pa;\n--[ 2022.10.25.11.38.52.167.0 ]--\nr 64         return pat;\n--[ 2022.10.25.11.38.52.303.0 ]--\nr 64         return path;\n--[ 2022.10.25.11.38.52.657.0 ]--\nr 64         return pathS;\n--[ 2022.10.25.11.38.52.838.0 ]--\nr 64         return pathSt;\n--[ 2022.10.25.11.38.52.942.0 ]--\nr 64         return pathSta;\n--[ 2022.10.25.11.38.53.031.0 ]--\nr 64         return pathStar;\n--[ 2022.10.25.11.38.53.218.0 ]--\nr 64         return pathStart;\n--[ 2022.10.25.11.38.55.148.0 ]--\nr 58     Coord pathStart ;    \n--[ 2022.10.25.11.38.55.283.0 ]--\nr 58     Coord pathStart =;    \n--[ 2022.10.25.11.38.55.397.0 ]--\nr 58     Coord pathStart = ;    \n--[ 2022.10.25.11.38.55.586.0 ]--\nr 58     Coord pathStart = n;    \n--[ 2022.10.25.11.38.55.782.0 ]--\nr 58     Coord pathStart = nu;    \n--[ 2022.10.25.11.38.55.949.0 ]--\nr 58     Coord pathStart = nul;    \n--[ 2022.10.25.11.38.56.068.0 ]--\nr 58     Coord pathStart = null;    \n--[ 2022.10.25.11.39.26.306.0 ]--\n+ 58     Coord pathStart = null;  \nr 59     \n--[ 2022.10.25.11.39.27.196.0 ]--\nr 59     C\n--[ 2022.10.25.11.39.27.524.0 ]--\nr 59     Co\n--[ 2022.10.25.11.39.27.628.0 ]--\nr 59     Coo\n--[ 2022.10.25.11.39.27.764.0 ]--\nr 59     Coor\n--[ 2022.10.25.11.39.28.007.0 ]--\nr 59     Coord\n--[ 2022.10.25.11.39.28.468.0 ]--\nr 59     Coord \n--[ 2022.10.25.11.39.28.758.0 ]--\nr 59     Coord p\n--[ 2022.10.25.11.39.28.814.0 ]--\nr 59     Coord pa\n--[ 2022.10.25.11.39.28.971.0 ]--\nr 59     Coord pat\n--[ 2022.10.25.11.39.29.068.0 ]--\nr 59     Coord path\n--[ 2022.10.25.11.39.29.429.0 ]--\nr 59     Coord pathE\n--[ 2022.10.25.11.39.29.613.0 ]--\nr 59     Coord pathEn\n--[ 2022.10.25.11.39.29.747.0 ]--\nr 59     Coord pathEnd\n--[ 2022.10.25.11.39.30.117.0 ]--\nr 59     Coord pathEnd \n--[ 2022.10.25.11.39.30.316.0 ]--\nr 59     Coord pathEnd =\n--[ 2022.10.25.11.39.30.390.0 ]--\nr 59     Coord pathEnd = \n--[ 2022.10.25.11.39.30.809.0 ]--\nr 59     Coord pathEnd = n\n--[ 2022.10.25.11.39.31.001.0 ]--\nr 59     Coord pathEnd = nu\n--[ 2022.10.25.11.39.31.148.0 ]--\nr 59     Coord pathEnd = nul\n--[ 2022.10.25.11.39.31.244.0 ]--\nr 59     Coord pathEnd = null\n--[ 2022.10.25.11.39.31.524.0 ]--\nr 59     Coord pathEnd = null;\n--[ 2022.10.25.11.39.36.383.0 ]--\n+ 69         \n--[ 2022.10.25.11.39.36.898.0 ]--\nr 69         p\n--[ 2022.10.25.11.39.36.987.0 ]--\nr 69         pa\n--[ 2022.10.25.11.39.37.088.0 ]--\nr 69         pat\n--[ 2022.10.25.11.39.37.198.0 ]--\nr 69         path\n--[ 2022.10.25.11.39.37.660.0 ]--\nr 69         pathE\n--[ 2022.10.25.11.39.37.921.0 ]--\nr 69         pathEn\n--[ 2022.10.25.11.39.37.997.0 ]--\nr 69         pathEnd\n--[ 2022.10.25.11.39.38.353.0 ]--\nr 69         pathEnd \n--[ 2022.10.25.11.39.38.441.0 ]--\nr 69         pathEnd =\n--[ 2022.10.25.11.39.38.580.0 ]--\nr 69         pathEnd = \n--[ 2022.10.25.11.39.38.816.0 ]--\nr 69         pathEnd = l\n--[ 2022.10.25.11.39.38.971.0 ]--\nr 69         pathEnd = lo\n--[ 2022.10.25.11.39.39.023.0 ]--\nr 69         pathEnd = loc\n--[ 2022.10.25.11.39.39.457.0 ]--\nr 69         pathEnd = loc;\n--[ 2022.10.25.11.39.41.610.0 ]--\nr 73         return p;\n--[ 2022.10.25.11.39.41.726.0 ]--\nr 73         return pa;\n--[ 2022.10.25.11.39.41.852.0 ]--\nr 73         return pat;\n--[ 2022.10.25.11.39.42.114.0 ]--\nr 73         return path;\n--[ 2022.10.25.11.39.42.470.0 ]--\nr 73         return pathE;\n--[ 2022.10.25.11.39.42.688.0 ]--\nr 73         return pathEn;\n--[ 2022.10.25.11.39.42.729.0 ]--\nr 73         return pathEnd;\n--[ 2022.10.25.11.39.47.683.0 ]--\n- 71\n--[ 2022.10.25.11.39.51.372.0 ]--\n- 63\n--[ 2022.10.25.11.40.43.617.0 ]--\nr 58     Coord pathStart = null;\n--[ 2022.10.25.11.40.55.614.0 ]--\n- 58\nr 58 \n--[ 2022.10.25.11.40.57.506.0 ]--\n+ 55     Coord pathStart = null;\nr 56     Coord pathEnd = null;\n--[ 2022.10.25.11.40.59.362.0 ]--\n- 59\n--[ 2022.10.25.11.41.04.649.0 ]--\n+ 55     \n--[ 2022.10.25.11.43.51.682.0 ]--\n+ 85         \n--[ 2022.10.29.13.46.34.843.0 ]--\n+ 103 <<<<<<< HEAD\n+ 104         // use a binary heap?\n+ 105         Coord front = getPathStart(); // front queue item will be the start of the path\n+ 106         int row = pathStart.getI(); // returns row\n+ 107         int col = pathStart.getJ(); // returns col\n+ 108         // I think we should implement BinomialMinPQ.java here for our priority queue implementation?\n+ 109         // I'm open to change though\n+ 110 =======\n+ 149 >>>>>>> a260a08 (computePath)\n--[ 2022.10.29.13.46.34.871.0 ]--\nUpdateTree (AD): 18 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9\n+ /.git/objects/21/86213986a340219401746588209691c3a095a9\n+ /.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1\n+ /.git/objects/57/48b108bdc945c49a7a22525e7f115334cb1314\n+ /.git/objects/66/cac0def9077c483f8b403da0322603b318e347\n+ /.git/objects/68/5025073ac6b980ab26461833cdd4d57cbe4d2d\n+ /.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc\n+ /.git/objects/81/415deddeaf54572c1897620ff4219df0bccf6c\n+ /.git/objects/8a/ddb3b2f6de9b99de7882a6c54afc5707148f06\n+ /.git/objects/8c/9d4b1873c2d88d47e50ec454cfd4a1b1721930\n+ /.git/objects/99/fc95060d508a3b5990b31df2ec2b5d565dfcaa\n+ /.git/objects/a1/8511806924333139ebf4a97a83d77f2ac48d01\n+ /.git/objects/a2/60a0876851af8bbc28ad400b1586217be8fe03\n+ /.git/objects/a5/142198d6b3120089f3d851541e0b10d8efa7cf\n+ /.git/objects/bf/d803b8e3653af5834138691ea8521bcaa694d7\n+ /.git/objects/cc/67a514baf96f57a38399f88f1f9b471c4b80e4\n+ /.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78\n+ /.git/objects/df/ab375b6db323649427d9b468018424e7b318ad\n\n--[ 2022.10.29.13.46.34.877.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.895.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.902.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.906.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.910.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.913.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.917.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.921.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.925.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.931.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.935.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.34.939.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.781.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.790.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.792.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.794.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.797.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.805.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.807.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.809.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.812.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.814.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.816.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.818.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.825.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.827.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.829.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.831.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.833.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.46.44.835.0 ]--\nUpdateTree (AD): 2 2\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_49_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_49__Default_.xml\n\n--[ 2022.10.29.13.47.15.013.0 ]--\n- 103\n- 103\n- 103\n- 103\n- 103\n- 103\n- 103\n- 103\n- 141\n--[ 2022.10.29.13.47.15.016.0 ]--\nUpdateTree (AD): 27 0\n+ /out/production/P04_Pathfinding/.donotlog\n+ /out/production/P04_Pathfinding/algs4.jar\n+ /out/production/P04_Pathfinding/stdlib.jar\n+ /out/production/P04_Pathfinding/Coord.class\n+ /out/production/P04_Pathfinding/png2emap.py\n+ /out/production/P04_Pathfinding/Walker.class\n+ /out/production/P04_Pathfinding/ramp.png.emap\n+ /out/production/P04_Pathfinding/Terrain.class\n+ /out/production/P04_Pathfinding/ramp2.png.emap\n+ /out/production/P04_Pathfinding/ramp3.png.emap\n+ /out/production/P04_Pathfinding/mazeAB.png.emap\n+ /out/production/P04_Pathfinding/usa128.png.emap\n+ /out/production/P04_Pathfinding/usa256.png.emap\n+ /out/production/P04_Pathfinding/Pathfinder.class\n+ /out/production/P04_Pathfinding/usa1024.png.emap\n+ /out/production/P04_Pathfinding/maze32_0.png.emap\n+ /out/production/P04_Pathfinding/maze32_1.png.emap\n+ /out/production/P04_Pathfinding/maze232_0.png.emap\n+ /out/production/P04_Pathfinding/maze320_0.png.emap\n+ /out/production/P04_Pathfinding/mazeBrain.png.emap\n+ /out/production/P04_Pathfinding/TerrainEditor.class\n+ /out/production/P04_Pathfinding/Pathfinder$PFNode.class\n+ /out/production/P04_Pathfinding/PathfinderVisualizer.class\n+ /out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_13_46_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml\n\n--[ 2022.10.29.13.47.27.978.0 ]--\nUpdateTree (AD): 1 0\n+ /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__13_46__Default_.xml\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.log/history.log b/.log/history.log
--- a/.log/history.log	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ b/.log/history.log	(date 1667677025669)
@@ -1608,3 +1608,5631 @@
 UpdateTree (AD): 1 0
 + /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__13_46__Default_.xml
 
+--[ 2022.11.02.14.11.47.115.0 ]--
+NewLogger: P04_Pathfinding
+Version: 1.5
+--[ 2022.11.02.14.11.47.318.0 ]--
+InitTree:
+/out/production/P04_Pathfinding/.donotlog
+/out/production/P04_Pathfinding/algs4.jar
+/out/production/P04_Pathfinding/stdlib.jar
+/out/production/P04_Pathfinding/Coord.class
+/out/production/P04_Pathfinding/png2emap.py
+/out/production/P04_Pathfinding/Walker.class
+/out/production/P04_Pathfinding/ramp.png.emap
+/out/production/P04_Pathfinding/Terrain.class
+/out/production/P04_Pathfinding/ramp2.png.emap
+/out/production/P04_Pathfinding/ramp3.png.emap
+/out/production/P04_Pathfinding/mazeAB.png.emap
+/out/production/P04_Pathfinding/usa128.png.emap
+/out/production/P04_Pathfinding/usa256.png.emap
+/out/production/P04_Pathfinding/Pathfinder.class
+/out/production/P04_Pathfinding/usa1024.png.emap
+/out/production/P04_Pathfinding/maze32_0.png.emap
+/out/production/P04_Pathfinding/maze32_1.png.emap
+/out/production/P04_Pathfinding/maze232_0.png.emap
+/out/production/P04_Pathfinding/maze320_0.png.emap
+/out/production/P04_Pathfinding/mazeBrain.png.emap
+/out/production/P04_Pathfinding/TerrainEditor.class
+/out/production/P04_Pathfinding/Pathfinder$PFNode.class
+/out/production/P04_Pathfinding/PathfinderVisualizer.class
+/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+/src/algs4.jar
+/src/Coord.java
+/src/stdlib.jar
+/src/Walker.java
+/src/Terrain.java
+/src/Pathfinder.java
+/src/TerrainEditor.java
+/src/PathfinderVisualizer.java
+/src/InteractivePathfinderVisualizer.java
+/.git/info/exclude
+/.git/logs/refs/heads/main
+/.git/logs/refs/remotes/origin/main
+/.git/logs/HEAD
+/.git/refs/heads/main
+/.git/refs/remotes/origin/main
+/.git/hooks/update.sample
+/.git/hooks/pre-push.sample
+/.git/hooks/commit-msg.sample
+/.git/hooks/pre-commit.sample
+/.git/hooks/pre-rebase.sample
+/.git/hooks/post-update.sample
+/.git/hooks/pre-receive.sample
+/.git/hooks/applypatch-msg.sample
+/.git/hooks/pre-applypatch.sample
+/.git/hooks/pre-merge-commit.sample
+/.git/hooks/push-to-checkout.sample
+/.git/hooks/fsmonitor-watchman.sample
+/.git/hooks/prepare-commit-msg.sample
+/.git/objects/00/83268a14a16b4a5dd867518f78733391a45c17
+/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+/.git/objects/02/b01225b71d3414a2e2cc73cafd334173831774
+/.git/objects/08/03327110344bdd9225216d43717854bdcb5a02
+/.git/objects/0a/0cc74c3c69529bc0b35efec4b33b4122f3f9d2
+/.git/objects/0a/223ed78fd4ba9e3c29d48824487e673a123de6
+/.git/objects/11/96e8a2e363c7dabd777bfe6bc8bd9c4f24983d
+/.git/objects/11/f974299e37fea0743352c5bb44bd670176a9c4
+/.git/objects/12/b0c09257d01178df8b7f1060740432172d7b42
+/.git/objects/13/ac099b7d719505f83e4bcc7f8d3e3324233f0e
+/.git/objects/14/1a3f4b2369df3af5a953caed0c4cab5f978deb
+/.git/objects/14/98d3ed54fd6d24a517dbb6edfdb89592a3a42f
+/.git/objects/17/9f9a625eb41082f81a6ba399335a590c13065d
+/.git/objects/19/758b3cfb8d02709de9b698387494c8b840197a
+/.git/objects/19/8f86a451262bb58f20fec4b4372511d319cb1e
+/.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9
+/.git/objects/1d/9870f3870280622cc38ff3a0db5d362720a2c9
+/.git/objects/1d/ba1a0866ebec020b4fff86ea9bec07c9be5f9c
+/.git/objects/1e/1b111e44a3392c3dc2f8c9e8466a2caa4c87f1
+/.git/objects/21/86213986a340219401746588209691c3a095a9
+/.git/objects/22/d1da271c9ad5057fed4e6702f0c556345d4b1e
+/.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1
+/.git/objects/29/3bba6c1d610b4ce86b15d1a807bfd9512e1e31
+/.git/objects/2e/c358f7bcf4f758b64b2f2d516d8aadd28268c4
+/.git/objects/2f/8959443fe58250b1251ba5223cef6fae049f6a
+/.git/objects/2f/9b1b9136e49f3aa4604e0907ea0497bd459bc9
+/.git/objects/30/27eb765074649989e38ee5953c045f541f2514
+/.git/objects/31/0e1d1baa102c6827797e192b38e3f6d8629fc6
+/.git/objects/31/fd9bbe5bb6e815ef3de6539321474dc6aec3b3
+/.git/objects/33/ebf301bb19589b3acf4d18d1fc9bd8f90302f4
+/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+/.git/objects/35/21629ecf5199e7d9a5a177d2937d17e36b73d3
+/.git/objects/36/bd4febfa8552f3cead1307339c48c6a2c9afb9
+/.git/objects/38/57c26673f53453f16ced8fe4cb6e8efd294f3a
+/.git/objects/39/122c7c3262ceff1338c9cc29fd32418783debf
+/.git/objects/3d/dd471797ab3fd4fdaa9102e86d087b9c85ae6c
+/.git/objects/3e/7c188a1be72d5f1cce5cdf5779924b039be66a
+/.git/objects/43/e81b1e944a8a3a9f9e42f72a0c1140f9633327
+/.git/objects/44/3d1398732fb006321a93e89dc6ccbcc76cefb6
+/.git/objects/46/58c672f584d326af787728f4e52bb379ffbf98
+/.git/objects/47/bfeee24fec7f21d5ff12c1c28cc444d9ddba85
+/.git/objects/49/1df43ab4b5595701f6f144d36d667d96a0a282
+/.git/objects/49/d6a74a87046e6d92d7453d56a4da013dee44ff
+/.git/objects/4a/25ed2698823ce5825bc66c5a5c767c54af7731
+/.git/objects/4d/137de7a049bcd5094c3a60d8357d28d0b68990
+/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+/.git/objects/54/d71d3d486b9af299988fade384c5fb18962bc9
+/.git/objects/55/e133c8e1aa563ba7414e9ae3501bf8306293b2
+/.git/objects/56/c7b9737bf41d32b2b80dfaaba4b83b3237caae
+/.git/objects/59/631287f07bbd6e06894075d7a1b44ef1bd90d2
+/.git/objects/5d/7b147a2b1a70bc90f896e209482051cac3b3e0
+/.git/objects/5f/d0d49fc87a408e940f89257a84e42fd26db3f2
+/.git/objects/61/906e850d3f83444507ecdc1fb9e085222104b5
+/.git/objects/67/ddd10fe349dc2acf922eea2b4a3e4fa5ea9429
+/.git/objects/68/5ce9f76ca15d09cf6e1be3e02b1a75ed9ad67d
+/.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc
+/.git/objects/6b/44ad28de6abbea42fc01b18dce452103d9e7f6
+/.git/objects/6b/5cf7797e750cc6bfa17f8e214898cc20423a3f
+/.git/objects/6b/9b0a44c59f31c1431e5570954d90fdd726418d
+/.git/objects/6c/246424f93893cd073f3d1bd7f636fcdf2a8f6b
+/.git/objects/6c/f072a973f0e9b5df5708bc22f87d48cea5f3c0
+/.git/objects/6e/32fb5b36fb51d2d009519c061beb1b92f7b568
+/.git/objects/6e/43436847378f923cf6d07ac36edb0b7c6d94b6
+/.git/objects/6f/21b8c406d74ee4404188aab137e27a3ad825af
+/.git/objects/6f/f8fa664f641464a3c3a5680c2fc82cef12381f
+/.git/objects/71/411d71fbf4bcfaa03b646fa35c27d996f9d52e
+/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+/.git/objects/77/2704d8527483dc9bd3881838b5ae736e6a3080
+/.git/objects/7a/f0745ca3fa03f03d1553a4c3cdfb74644f9e67
+/.git/objects/7e/d0b31d9dbdcdd0e1f796f94a8a0edee9188f76
+/.git/objects/7f/1d432fbe858693e07e0f8841e84c792af2031d
+/.git/objects/7f/b0d4d339e78998d525baf7d47c1bb8a7ee05de
+/.git/objects/80/22bc8bdf4cb285c65c6e05758f2a53a2a19be6
+/.git/objects/80/2c90f38a670110c5b39e678067d43aa56af5f8
+/.git/objects/85/ce4526c7499f9d59944e1e006278d669c09343
+/.git/objects/87/616f238482a6137fa0e9ecf3b29a47e08ba574
+/.git/objects/88/ecd90b14e8bd5850f801f539c4edeec367a1ad
+/.git/objects/8d/2d97a18f77e17c906c6f06e314308254d3014d
+/.git/objects/8e/5fca5fd0d4a83341928232bebb03ddc063fa39
+/.git/objects/90/c179d86e49e8f9cb01f9f441c21477b64b8cd8
+/.git/objects/91/69f879d5c8964f429329cacbb228d900a0f368
+/.git/objects/93/a9ff49344da6ca9b0bc1754a35a8642b385561
+/.git/objects/96/3aff0b633cf34ac705e22de6d5f7052727ebd4
+/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+/.git/objects/97/b899881080136b7329ecccd6a8ff2462d5241b
+/.git/objects/9a/6474cc575269218262e5befaf996589b4b0725
+/.git/objects/a1/68398a440f4c5345b3b3565e9f86f87edab677
+/.git/objects/a4/2329826914d12946dca5006a756bd71d2e40a6
+/.git/objects/a5/c96ae3c6227dc41e4ec78126f6331112f18d28
+/.git/objects/a8/e2b1bf7684eb227f451507d3a2426bfe896c8f
+/.git/objects/a9/7e1ab2919f0342e08b4871f42597fc25cba4ac
+/.git/objects/a9/cfc582bac4e2f77cb3a782cce2276797e3cf6d
+/.git/objects/aa/89a00b93e7cebdbd94d5acb4d83d98a3d23ae4
+/.git/objects/ac/0a3f4ff245717751593bf94456a23062670281
+/.git/objects/ac/14d6758736a7039859e268380d59a3b326b399
+/.git/objects/b2/3b264149f35fafc61fc64e209a58ec653e8560
+/.git/objects/b9/b281651bbdd7a26d9a588cfec35c0470aa921b
+/.git/objects/be/bbdf2844f2f1e3a5f33e187b312baa769c280a
+/.git/objects/bf/b3e39173d53801417602636de619113423353a
+/.git/objects/c0/6c06bae75f4eadb6f3b484daaf0df95379fea0
+/.git/objects/c1/c4ebd69aa9312836630aa6b99ca0252ee2f0ae
+/.git/objects/c2/fdd0799e3b7cf389c83410273861f583ae8716
+/.git/objects/c3/e53b84164752b49157a170c31cc7533f5d2fee
+/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+/.git/objects/c9/37f78182ddde0206560e0e602788143fdb5b9d
+/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+/.git/objects/cd/5da4c8fba2eb39aace10ad59a84be6d094862d
+/.git/objects/d0/16713dfcdd945a90764e59637156e4e77b239a
+/.git/objects/d0/59b6e9c195a2a7ce448272efd11719d3715c61
+/.git/objects/d0/a590a1e82da3c72a9484491b61e6bccaf4b6e3
+/.git/objects/d0/d5683a4b63386ff54b787640fcf8c1e9ce605b
+/.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78
+/.git/objects/d1/cbca8c4639e7e89c458a3c273f0acebd9ebe1a
+/.git/objects/d2/0302c9b0f578ec42967969e2892bc4416d66ca
+/.git/objects/d5/62bfa38c545099391ee84f30644aca5c4e04a3
+/.git/objects/d6/81f37c2ad71d1a24bfccf5c039cb90a8b74b6e
+/.git/objects/da/116ccca88cede3c380ac4f2910e7fbfec3c98c
+/.git/objects/de/8b77f039b60bc7ef5ca03a85e9712c734fb3c0
+/.git/objects/df/54c5a865dbf20b853a1e12c04a01c76b3a9285
+/.git/objects/df/ab375b6db323649427d9b468018424e7b318ad
+/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+/.git/objects/e7/0c3da4a581efea1f3c3cecbcadf932c80ee641
+/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+/.git/objects/ea/f2034dc4702cda5cdea9276aa329109efd76f1
+/.git/objects/eb/02039079a5e73413c80696c73153fca1810484
+/.git/objects/f1/3b51941ba05149023344e796411aa0c6a438cb
+/.git/objects/f1/7257c6cddd76fb6c04620a5cca5065726c7022
+/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+/.git/objects/f3/e544736920f9d8e349dae1185582ef78300898
+/.git/objects/f4/a9130b95f1231b86c72ef6d1ce3c3c8198905e
+/.git/objects/f5/4b8fcefc1c6a57a32eb9779db43168b0186fe0
+/.git/objects/f6/07a662cc46985756ea5b4f041dc23347f24769
+/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+/.git/objects/fc/ccbf936220654899cea62a94163562ca9ebcef
+/.git/objects/fc/cd7f38f6769c6fc941db1b04fa52f06088c55b
+/.git/HEAD
+/.git/index
+/.git/config
+/.git/ORIG_HEAD
+/.git/FETCH_HEAD
+/.git/description
+/.git/COMMIT_EDITMSG
+/.log/history.log
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_8_24_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__8_24_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__1_50_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml
+/.idea/copyright/profiles_settings.xml
+/.idea/libraries/algs4.xml
+/.idea/libraries/stdlib.xml
+/.idea/.name
+/.idea/vcs.xml
+/.idea/misc.xml
+/.idea/modules.xml
+/.idea/compiler.xml
+/.idea/workspace.xml
+/.idea/uiDesigner.xml
+/tests/.donotlog
+/tests/png2emap.py
+/tests/ramp.png.emap
+/tests/ramp2.png.emap
+/tests/ramp3.png.emap
+/tests/mazeAB.png.emap
+/tests/usa128.png.emap
+/tests/usa256.png.emap
+/tests/usa1024.png.emap
+/tests/maze32_0.png.emap
+/tests/maze32_1.png.emap
+/tests/maze232_0.png.emap
+/tests/maze320_0.png.emap
+/tests/mazeBrain.png.emap
+/.cos265
+/readme.html
+/P04_Pathfinding.iml
+
+--[ 2022.11.02.14.11.47.321.0 ]--
+InitFile: /src/Walker.java
+import java.util.Iterator;
+
+/**
+ * Walker takes an Iterable of Coords and simulates an individual
+ * walking along the path over the given Terrain
+ */
+public class Walker {
+
+    // terrain: the Terrain the Walker traverses
+    // path: the sequence of Coords the Walker follows
+    public Walker(Terrain terrain, Iterable<Coord> path) {
+    }
+
+    // returns the Walker's current location
+    public Coord getLocation() {
+        return null;
+    }
+
+    // returns true if Walker has reached the end Coord (last in path)
+    public boolean doneWalking() {
+        return true;
+    }
+
+    // advances the Walker along path
+    // byTime: how long the Walker should traverse (may be any non-negative value)
+    public void advance(float byTime) {
+    }
+
+}
+
+--[ 2022.11.02.14.11.47.322.0 ]--
+InitFile: /src/Coord.java
+/**
+ * Coordinates is an immutable type that store the tuple (i, j)
+ */
+public final class Coord {
+    private final int i;
+    private final int j;
+
+    public Coord(int i, int j) {
+        this.i = i;
+        this.j = j;
+    }
+
+    public int getI() { return i; }
+    public int getJ() { return j; }
+
+    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
+        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
+    }
+    public boolean isInBounds(Coord min, Coord max) {
+        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
+    }
+
+    public Coord add(int addI, int addJ) {
+        return new Coord(i + addI, j + addJ);
+    }
+    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }
+
+    public String toString() { return "(" + i + "," + j + ")"; }
+
+    public boolean equals(Object o) {
+        if(this == o) return true;
+        if(o == null) return false;
+        if(o.getClass() != this.getClass()) return false;
+        Coord that = (Coord) o;
+        if(this.i != that.i) return false;
+        if(this.j != that.j) return false;
+        return true;
+    }
+}
+
+--[ 2022.11.02.14.11.47.323.0 ]--
+InitFile: /src/InteractivePathfinderVisualizer.java
+import java.awt.event.KeyEvent;
+//kate was here
+/**
+ * InteractivePathfinderVisualizer visualizes the terrain and the computed
+ * path and allows the user to change parameters of the Pathfinder.  Below
+ * is a list of commands and what they do.  Note: some of the commands
+ * modify the properties of the path finder and some modify the terrain.
+ *
+ * Command        Action                                      Terrain
+ * C              clear path
+ * space          recompute path
+ * S/E            set start/end location to mouse
+ * left/right     halve/double path search heuristic value
+ * 0/1            set path search heuristic to 0 or 1
+ * W              start a walker to show the path
+ * R              randomly generate a new terrain                *
+ * M              smooths terrain under mouse                    *
+ * shift+M        smooths all terrain                            *
+ * up/down        increase/decrease terrain under mouse          *
+ */
+
+public class InteractivePathfinderVisualizer {
+    private final static int DELAY = 10;
+
+    // sets how many redraws it should take for the walker to reach its destination
+    private final static float STEPS_TO_WALK = 100.0f;
+
+    // for convenience, here are the emap files that are located under heightmaps/ folder
+    // the python script in that folder converts png files to emap. \
+    // you can use it to create your own maps to test your code
+    private final static String[] emaps = {
+            "maze32_0.png.emap",    // 0   (32x32 maze)
+            "maze32_1.png.emap",    // 1   (another 32x32 maze)
+            "maze232_0.png.emap",   // 2   (232x232 maze)
+            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
+            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
+            "mazeBrain.png.emap",   // 5   (...)
+            "ramp.png.emap",        // 6   (some tests)
+            "ramp2.png.emap",       // 7   (...)
+            "ramp3.png.emap",       // 8   (...)
+            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
+            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
+            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
+    };
+
+    private final static String emapFilename = emaps[2];        // change index to load a different elevation map
+
+
+
+    public static void main(String[] args) {
+        Terrain terrain = new Terrain(emapFilename);
+        Pathfinder pf = new Pathfinder(terrain);
+        int N = terrain.getN();
+
+        StdDraw.show(0);
+
+        // set default starting and ending locations
+        pf.setPathStart(new Coord(1, 1));
+        pf.setPathEnd(new Coord(N-3, N-3));
+
+        // find a path
+        pf.resetPath();
+        pf.computePath();
+
+        PathfinderVisualizer.draw(terrain, pf, null, N);
+        StdDraw.show(DELAY);
+
+        // prevent repeated applications
+        boolean keyboardR = false;
+        boolean keyboardM = false;
+
+        Walker walker = null;
+
+        while(true) {
+            boolean recompute = false;
+            boolean redraw = false;
+
+            // mouse location on map
+            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
+            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
+            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
+                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
+                float m = keyboardLeft ? 0.5f : 2.0f;
+                float h = pf.getHeuristic() * m;
+                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
+                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
+                float h = keyboard0 ? 0 : 1;
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
+                pf.resetPath();
+                walker = null;
+                redraw = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
+                TerrainEditor.setFractalHeights(terrain);
+                TerrainEditor.clampHeights(terrain);
+                recompute = true;
+            }
+            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
+                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
+                    if(!keyboardM) {
+                        TerrainEditor.smoothHeights(terrain);
+                        recompute = true;
+                    }
+                } else {
+                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
+                    recompute = true;
+                }
+            }
+            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
+                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
+                float add = keyboardUp ? 8.0f : -8.0f;
+                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
+                pf.setPathStart(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
+                pf.setPathEnd(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
+                Iterable<Coord> path = pf.getPathSolution();
+                if(path != null) {
+                    walker = new Walker(terrain, pf.getPathSolution());
+                }
+            }
+
+            if(walker != null) {
+                if(walker.doneWalking()) {
+                    walker = null;
+                } else {
+                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
+                }
+                redraw = true;
+            }
+
+            if(recompute) {
+                walker = null;
+                pf.resetPath();
+                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
+                    pf.computePath();
+                }
+                redraw = true;
+            }
+
+            if(redraw) {
+                PathfinderVisualizer.draw(terrain, pf, walker, N);
+                StdDraw.show(DELAY);
+            } else {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    /* do nothing */
+                }
+            }
+        }
+    }
+}
+
+--[ 2022.11.02.14.11.47.323.1 ]--
+InitFile: /src/Terrain.java
+import java.lang.IndexOutOfBoundsException;
+
+/**
+ * Terrain stores elevations for map and computes distance and
+ * cost in traversing the terrain.
+ */
+
+public class Terrain {
+    private int N;
+    private int[][] heights;
+
+    public Terrain(int N) {
+        this.N = N;
+        this.heights = new int[N][N];
+    }
+
+    public Terrain(int[][] heights) {
+        this.N = heights.length;
+        this.heights = heights;
+    }
+
+    public Terrain(String emapfile) {
+        In in = new In(emapfile);
+        this.N = in.readInt();
+        this.heights = new int[N][N];
+        for (int j = 0; j < N; j++) {
+            for (int i = 0; i < N; i++) {
+                this.heights[i][j] = in.readInt();
+            }
+        }
+    }
+
+    public int getN() {
+        return N;
+    }
+
+    public void setHeight(int i, int j, int h) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        heights[i][j] = h;
+    }
+    public void setHeight(int i, int j, float h) {
+        setHeight(i, j, (int) h);
+    }
+    public void setHeight(Coord loc, int h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+    public void setHeight(Coord loc, float h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+
+    public int getHeight(int i, int j) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        return heights[i][j];
+    }
+    public int getHeight(Coord loc) {
+        return getHeight(loc.getI(), loc.getJ());
+    }
+
+    // computes distance between (i0,j0) and (i1,j1) as the crow flies
+    public float computeDistance(int i0, int j0, int i1, int j1) {
+        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+    }
+    public float computeDistance(Coord c0, Coord c1) {
+        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+
+    public float computeTravelCost(int i0, int j0, int i1, int j1) {
+        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
+        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
+        float dist = computeDistance(i0,j0, i1,j1);
+        return (1.0f + climb) * dist;
+    }
+    public float computeTravelCost(Coord c0, Coord c1) {
+        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+    public float computeTravelCost(Iterable<Coord> cs) {
+        Coord c0 = null;
+        float cost = 0.0f;
+        for(Coord c1 : cs) {
+            if(c0 != null) cost += computeTravelCost(c0, c1);
+            c0 = c1;
+        }
+        return cost;
+    }
+}
+
+--[ 2022.11.02.14.11.47.323.2 ]--
+InitFile: /.cos265
+
+
+--[ 2022.11.02.14.11.47.323.3 ]--
+InitFile: /src/TerrainEditor.java
+/**
+ * The following class provides some simple terrain editing functions.
+ */
+public class TerrainEditor {
+    private static float rndRadius(float d) {
+        return (float)StdRandom.uniform(-d,d);
+    }
+
+    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
+        int N = terrain.getN();
+        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
+        if(!isset[i + j * N]) {
+            isset[i + j * N] = true;
+            terrain.setHeight(i, j, dh);
+        }
+        return terrain.getHeight(i,j);
+    }
+
+    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
+        int id = i1-i0;
+        int jd = j1-j0;
+        int i01 = (i0+i1)/2;
+        int j01 = (j0+j1)/2;
+
+        if(id <= 1 && jd <= 1) return;
+
+        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
+        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
+        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
+        float h11 = getFractalHeight(i1,j1,32,terrain,isset);
+
+        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);
+
+        float d0001 = (h00 + h01) / 2 + rndRadius(d);
+        float d0010 = (h00 + h10) / 2 + rndRadius(d);
+        float d1101 = (h11 + h01) / 2 + rndRadius(d);
+        float d1110 = (h11 + h10) / 2 + rndRadius(d);
+
+        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
+        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
+        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
+        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);
+
+        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
+        float hm = getFractalHeight(i01, j01, dm, terrain,isset);
+
+        if(id > 1 && jd > 1) {
+            setFractalHeights(i0, j0, i01, j01, terrain, isset);
+            setFractalHeights(i01, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i01, j1, terrain, isset);
+            setFractalHeights(i01, j01, i1, j1, terrain, isset);
+        } else if(jd > 1) {
+            setFractalHeights(i0, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i1, j1, terrain, isset);
+        } else {
+            setFractalHeights(i0, j0, i01, j1, terrain, isset);
+            setFractalHeights(i01, j0, i1, j1, terrain, isset);
+        }
+    }
+
+    public static void setFractalHeights(Terrain terrain) {
+        int N = terrain.getN();
+        boolean[] isset = new boolean[N*N];
+        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
+    }
+
+    public static void smoothHeights(Terrain terrain) {
+        int N = terrain.getN();
+        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
+        smoothHeights(N/2, N/2, radius, false, terrain);
+    }
+
+    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
+        final int N = terrain.getN();
+        final int w = 2*radius+1;
+        float[] s = new float[w*w];
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+
+                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
+                if(m <= 0.0000001) {
+                    s[sidx] = terrain.getHeight(i,j);
+                    continue;
+                }
+                float h = 0;
+                int c = 0;
+                if(i > 0 && j > 0) {
+                    h += terrain.getHeight(i-1,j-1);
+                    c += 1;
+                }
+                if(i < N-1 && j > 0) {
+                    h += terrain.getHeight(i+1,j-1);
+                    c += 1;
+                }
+                if(i > 0 && j < N-1) {
+                    h += terrain.getHeight(i-1,j+1);
+                    c += 1;
+                }
+                if(i < N-1 && j < N-1) {
+                    h += terrain.getHeight(i+1,j+1);
+                    c += 1;
+                }
+                if(i > 0) {
+                    h += terrain.getHeight(i-1,j);
+                    c += 1;
+                }
+                if(j > 0) {
+                    h += terrain.getHeight(i,j-1);
+                    c += 1;
+                }
+                if(i < N-1) {
+                    h += terrain.getHeight(i+1,j);
+                    c += 1;
+                }
+                if(j < N-1) {
+                    h += terrain.getHeight(i,j+1);
+                    c += 1;
+                }
+                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
+            }
+        }
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+                terrain.setHeight(i, j, s[sidx]);
+            }
+        }
+    }
+
+    public static void clampHeights(Terrain terrain) {
+        int N = terrain.getN();
+        for(int i = 0; i < N; i++) {
+            for(int j = 0; j < N; j++) {
+                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
+            }
+        }
+    }
+
+    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
+        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
+        if(!fallOff) return 1;
+        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
+        if(d2 > radius*radius) return 0;
+        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
+    }
+
+    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
+        final int N = terrain.getN();
+        for(int ja = -radius; ja <= radius; ja++) {
+            int r = j + ja;
+            if(r < 0 || r >= N) continue;
+            for(int ia = -radius; ia <= radius; ia++) {
+                int c = i + ia;
+                if(c < 0 || c >= N) continue;
+                float v = add * computeEffect(c, r, i, j, radius, true, N);
+                float h = terrain.getHeight(c, r) + v;
+                h = Math.max(0, Math.min(255, h));
+                terrain.setHeight(c, r, h);
+            }
+        }
+    }
+}
+
+--[ 2022.11.02.14.11.47.323.4 ]--
+InitFile: /P04_Pathfinding.iml
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.log" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="algs4" level="project" />
+    <orderEntry type="library" name="stdlib" level="project" />
+  </component>
+</module>
+
+--[ 2022.11.02.14.11.47.323.5 ]--
+InitFile: /src/PathfinderVisualizer.java
+/**
+ * PathfinderVisualizer visualizes the terrain and found path.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+
+public class PathfinderVisualizer {
+
+    // delay in milliseconds (controls animation speed)
+    private final static int DELAY = 100;
+
+    // color for different elevations.  must be in ascending order!
+    private final static int[][] elevationColors = {
+            // h    r   g   b   where h=height, r=red, g=green, b=blue
+            {  0,   0,  0,  0},
+            {  2,   0,  0,160},
+            {  4,   0,224,224},
+            { 16, 192,192,  0},
+            { 64,  16,255, 16},
+            {128,  32,224, 32},
+            {192, 128,128,  8},
+            {224, 164,164,164},
+            {255, 255,255,255}
+    };
+
+    private final static Color cStart    = new Color(128, 128, 255);
+    private final static Color cEnd      = new Color(255, 128, 128);
+    private final static Color cSolution = new Color(255, 128, 255);
+    private final static Color cSearched = new Color(128,   0, 128);
+
+    // linearly interpolating between the corresponding rgb values
+    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * r0 + v1 * r1);
+        int g = (int)(v0 * g0 + v1 * g1);
+        int b = (int)(v0 * b0 + v1 * b1);
+        return new Color(r, g, b);
+    }
+    private static Color colorLERP(float v1, Color c0, Color c1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
+        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
+        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
+        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
+        return new Color(r, g, b, a);
+    }
+
+    // returns color for given height
+    private static Color height2Color(int h) {
+        h = Math.max(0, Math.min(255, h));
+
+        int[] ec0 = elevationColors[0];  // default lower bound
+        int[] ec1 = elevationColors[1];  // default upper bound
+
+        // find upper bound while updating lower bound
+        for(int i = 1; i < elevationColors.length; i++) {
+            ec1 = elevationColors[i];
+            if(h >= ec0[0] && h <= ec1[0]) break;
+            ec0 = ec1;
+        }
+
+        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
+        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
+        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));
+
+        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
+    }
+
+    private static void drawCircle(int i, int j, int N, double rad) {
+        int c = (int)((i+0.5f) * 464.0f / N);
+        int r = (int)((j+0.5f) * 464.0f / N);
+        StdDraw.circle(c + 24, 464 - r + 36, rad);
+    }
+    public static void drawCircle(Coord loc, int N, double rad) {
+        drawCircle(loc.getI(), loc.getJ(), N, rad);
+    }
+
+    private static void drawPath(Iterable<Coord> path, int N) {
+        boolean first = true;
+        int c0 = 0, r0 = 0;
+        for (Coord loc : path) {
+            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
+            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
+            if(!first) {
+                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
+            }
+            first = false;
+            c0 = c1; r0 = r1;
+        }
+    }
+
+    // draw N-by-N pathfinding map
+    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
+        StdDraw.clear();
+        StdDraw.setXscale(0, 512);
+        StdDraw.setYscale(0, 512);
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.filledSquare(256, 256 + 12, 464 / 2);
+
+        // draw terrain
+        for(int row = 0; row < 464; row++) {
+            int j = (int)((float)row/464.0f * N);
+            for(int col = 0; col < 464; col++) {
+                int i = (int)((float)col/464.0f * N);
+                Coord loc = new Coord(i,j);
+                Color c = height2Color(terrain.getHeight(loc));
+                if(pf.wasSearched(loc)) {
+                    c = colorLERP(0.50f, c, cSearched);
+                }
+                StdDraw.setPenColor(c);
+                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
+            }
+        }
+
+        // draw path start
+        if(pf.getPathStart() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathStart(), N, 4.0);
+
+            StdDraw.setPenColor(cStart);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathStart(), N, 4.0);
+        }
+
+        // draw path end
+        if(pf.getPathEnd() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+
+            StdDraw.setPenColor(cEnd);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+        }
+
+        // draw found path
+        if(pf.foundPath()) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawPath(pf.getPathSolution(), N);
+
+            StdDraw.setPenColor(cSolution);
+            StdDraw.setPenRadius(0.002);
+            drawPath(pf.getPathSolution(), N);
+        }
+
+        // draw walker
+        if(walker != null) {
+            Coord loc = walker.getLocation();
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+
+            StdDraw.setPenColor(StdDraw.WHITE);
+            StdDraw.setPenRadius(0.002);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+        }
+
+        // write status text
+        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
+        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
+        else               StdDraw.text(256, 12, "no path found");
+        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
+    }
+}
+
+--[ 2022.11.02.14.11.47.324.0 ]--
+InitFile: /src/Pathfinder.java
+import java.lang.IndexOutOfBoundsException;
+import java.lang.IllegalArgumentException;
+
+/**
+ * Pathfinder uses A* search to find a near optimal path
+ * between to locations with given terrain.
+ */
+//hiiiiiiiiiiii
+    //this is Makayla...
+public class Pathfinder {
+
+    /**
+     * PFNode will be the key for MinPQ (used in computePath())
+     */
+    private class PFNode implements Comparable<PFNode> {
+        // loc: the location of the PFNode
+        // fromNode: how did we get here? (linked list back to start)
+        Coord location;
+        PFNode previous;
+        float cost;
+        public PFNode(Coord loc, PFNode fromNode, float newCost) {
+           location=loc;
+           previous=fromNode;
+           cost=newCost;
+        }
+
+        // compares this with that, used to find minimum cost PFNode
+        public int compareTo(PFNode that) {
+            return this.compareTo(that);
+        }
+
+        // returns the cost to travel from starting point to this
+        // via the fromNode chain
+        public float getCost(float heuristic) {
+
+            return 0;
+        }
+
+        // returns if this PFNode is still valid
+        public boolean isValid() {
+            return false;
+        }
+
+        // invalidates the PFNode
+        public void invalidate() {
+        }
+
+        // returns if the PFNode has been used
+        public boolean isUsed() {
+            return true;
+        }
+
+        // uses the PFNode
+        public void use() { }
+
+        // returns an Iterable of PFNodes that surround this
+        public Iterable<PFNode> neighbors() {
+            Stack<PFNode> s = new Stack<>();
+            s.push(new PFNode(null, null, 0));
+            return s;
+        }
+    }
+
+    public Pathfinder(Terrain terrain) {
+    }
+    Coord pathStart=null;
+    Coord pathEnd=null;
+    float heuristic = 1;
+    boolean pathFound=false;
+    public void setPathStart(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathStart=loc;
+    }
+
+    public Coord getPathStart() { // this function is a little redundant if we
+                                  // just have a global var for it anyway...
+        return pathStart;
+    }
+
+    public void setPathEnd(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathEnd=loc;
+    }
+
+    public Coord getPathEnd() {
+        return pathEnd;
+    }
+
+    public void setHeuristic(float v) {
+        heuristic=v;
+    }
+
+    public float getHeuristic() {
+        return heuristic;
+    }
+
+    //cleans out the queues ??
+    public void resetPath() {
+    }
+
+    public void computePath() {
+        // make the priorety queue
+        Terrain map = new Terrain("maze232_0.png.emap");
+        MinPQ<PFNode> PQ = new MinPQ<>();
+        PFNode start = new PFNode(pathStart, null, 0);
+        PQ.insert(start);
+        while (!pathFound) {
+            PFNode location = PQ.delMin();
+
+            if (location.location == pathEnd) {    //if the location is the end
+                pathFound = true;
+                return;
+            }
+
+            if (location == null) return;
+
+            Coord[] neighbourList = checkNeighbour(location.location);  //give all the neighbours
+            float previousCost = location.cost;
+            for (int i = 0; i < 4; i++) {
+                float cost = map.computeTravelCost(location.location, neighbourList[i]);
+                PFNode temp = new PFNode(neighbourList[i], location, cost);
+                PQ.insert(temp);
+            }
+        }
+    }
+
+    private Coord[] checkNeighbour(Coord loc){
+        int x = loc.getI();   //row
+        int y = loc.getJ();   //col
+
+        Coord[] neighbourList = new Coord[4];
+        neighbourList[0] = loc.add(0, 1);   //up
+        neighbourList[1] = loc.add(-1, 0);  //left
+        neighbourList[2] = loc.add(0, -1);  //down
+        neighbourList[3] = loc.add(1, 0);   //right
+
+        //edge cases
+
+        return neighbourList;
+
+    }
+
+    public boolean foundPath() {
+        return pathFound;
+    }
+
+    public float getPathCost() {
+        return 0;
+    }
+
+    public int getSearchSize() {
+        return 0;
+    }
+
+    public Iterable<Coord> getPathSolution() {
+        return null;
+    }
+
+    public boolean wasSearched(Coord loc) {
+        return false;
+    }
+}
+
+--[ 2022.11.02.14.11.52.084.0 ]--
+UpdateTree (AD): 0 3
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
+
+--[ 2022.11.02.14.11.52.119.0 ]--
+UpdateTree (AD): 3 3
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
++ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch
++ /.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch
++ /.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch
+
+--[ 2022.11.02.14.12.18.899.0 ]--
+DisposeComponent
+--[ 2022.11.03.16.14.42.126.0 ]--
+NewLogger: P04_Pathfinding
+Version: 1.5
+--[ 2022.11.03.16.14.42.362.0 ]--
+InitTree:
+/out/production/P04_Pathfinding/.donotlog
+/out/production/P04_Pathfinding/algs4.jar
+/out/production/P04_Pathfinding/stdlib.jar
+/out/production/P04_Pathfinding/Coord.class
+/out/production/P04_Pathfinding/png2emap.py
+/out/production/P04_Pathfinding/Walker.class
+/out/production/P04_Pathfinding/ramp.png.emap
+/out/production/P04_Pathfinding/Terrain.class
+/out/production/P04_Pathfinding/ramp2.png.emap
+/out/production/P04_Pathfinding/ramp3.png.emap
+/out/production/P04_Pathfinding/mazeAB.png.emap
+/out/production/P04_Pathfinding/usa128.png.emap
+/out/production/P04_Pathfinding/usa256.png.emap
+/out/production/P04_Pathfinding/Pathfinder.class
+/out/production/P04_Pathfinding/usa1024.png.emap
+/out/production/P04_Pathfinding/maze32_0.png.emap
+/out/production/P04_Pathfinding/maze32_1.png.emap
+/out/production/P04_Pathfinding/maze232_0.png.emap
+/out/production/P04_Pathfinding/maze320_0.png.emap
+/out/production/P04_Pathfinding/mazeBrain.png.emap
+/out/production/P04_Pathfinding/TerrainEditor.class
+/out/production/P04_Pathfinding/Pathfinder$PFNode.class
+/out/production/P04_Pathfinding/PathfinderVisualizer.class
+/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+/src/algs4.jar
+/src/Coord.java
+/src/stdlib.jar
+/src/Walker.java
+/src/Terrain.java
+/src/Pathfinder.java
+/src/TerrainEditor.java
+/src/PathfinderVisualizer.java
+/src/InteractivePathfinderVisualizer.java
+/.git/info/exclude
+/.git/logs/refs/heads/main
+/.git/logs/refs/remotes/origin/main
+/.git/logs/HEAD
+/.git/refs/heads/main
+/.git/refs/remotes/origin/main
+/.git/hooks/update.sample
+/.git/hooks/pre-push.sample
+/.git/hooks/commit-msg.sample
+/.git/hooks/pre-commit.sample
+/.git/hooks/pre-rebase.sample
+/.git/hooks/post-update.sample
+/.git/hooks/pre-receive.sample
+/.git/hooks/applypatch-msg.sample
+/.git/hooks/pre-applypatch.sample
+/.git/hooks/pre-merge-commit.sample
+/.git/hooks/push-to-checkout.sample
+/.git/hooks/fsmonitor-watchman.sample
+/.git/hooks/prepare-commit-msg.sample
+/.git/objects/00/83268a14a16b4a5dd867518f78733391a45c17
+/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+/.git/objects/02/b01225b71d3414a2e2cc73cafd334173831774
+/.git/objects/08/03327110344bdd9225216d43717854bdcb5a02
+/.git/objects/0a/0cc74c3c69529bc0b35efec4b33b4122f3f9d2
+/.git/objects/0a/223ed78fd4ba9e3c29d48824487e673a123de6
+/.git/objects/11/96e8a2e363c7dabd777bfe6bc8bd9c4f24983d
+/.git/objects/11/f974299e37fea0743352c5bb44bd670176a9c4
+/.git/objects/12/b0c09257d01178df8b7f1060740432172d7b42
+/.git/objects/13/ac099b7d719505f83e4bcc7f8d3e3324233f0e
+/.git/objects/14/1a3f4b2369df3af5a953caed0c4cab5f978deb
+/.git/objects/14/98d3ed54fd6d24a517dbb6edfdb89592a3a42f
+/.git/objects/17/9f9a625eb41082f81a6ba399335a590c13065d
+/.git/objects/19/758b3cfb8d02709de9b698387494c8b840197a
+/.git/objects/19/8f86a451262bb58f20fec4b4372511d319cb1e
+/.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9
+/.git/objects/1d/9870f3870280622cc38ff3a0db5d362720a2c9
+/.git/objects/1d/ba1a0866ebec020b4fff86ea9bec07c9be5f9c
+/.git/objects/1e/1b111e44a3392c3dc2f8c9e8466a2caa4c87f1
+/.git/objects/21/86213986a340219401746588209691c3a095a9
+/.git/objects/22/d1da271c9ad5057fed4e6702f0c556345d4b1e
+/.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1
+/.git/objects/29/3bba6c1d610b4ce86b15d1a807bfd9512e1e31
+/.git/objects/2e/c358f7bcf4f758b64b2f2d516d8aadd28268c4
+/.git/objects/2f/8959443fe58250b1251ba5223cef6fae049f6a
+/.git/objects/2f/9b1b9136e49f3aa4604e0907ea0497bd459bc9
+/.git/objects/30/27eb765074649989e38ee5953c045f541f2514
+/.git/objects/31/0e1d1baa102c6827797e192b38e3f6d8629fc6
+/.git/objects/31/fd9bbe5bb6e815ef3de6539321474dc6aec3b3
+/.git/objects/33/ebf301bb19589b3acf4d18d1fc9bd8f90302f4
+/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+/.git/objects/35/21629ecf5199e7d9a5a177d2937d17e36b73d3
+/.git/objects/36/bd4febfa8552f3cead1307339c48c6a2c9afb9
+/.git/objects/38/57c26673f53453f16ced8fe4cb6e8efd294f3a
+/.git/objects/39/122c7c3262ceff1338c9cc29fd32418783debf
+/.git/objects/3d/dd471797ab3fd4fdaa9102e86d087b9c85ae6c
+/.git/objects/3e/7c188a1be72d5f1cce5cdf5779924b039be66a
+/.git/objects/43/e81b1e944a8a3a9f9e42f72a0c1140f9633327
+/.git/objects/44/3d1398732fb006321a93e89dc6ccbcc76cefb6
+/.git/objects/46/58c672f584d326af787728f4e52bb379ffbf98
+/.git/objects/47/bfeee24fec7f21d5ff12c1c28cc444d9ddba85
+/.git/objects/49/1df43ab4b5595701f6f144d36d667d96a0a282
+/.git/objects/49/d6a74a87046e6d92d7453d56a4da013dee44ff
+/.git/objects/4a/25ed2698823ce5825bc66c5a5c767c54af7731
+/.git/objects/4d/137de7a049bcd5094c3a60d8357d28d0b68990
+/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+/.git/objects/54/d71d3d486b9af299988fade384c5fb18962bc9
+/.git/objects/55/e133c8e1aa563ba7414e9ae3501bf8306293b2
+/.git/objects/56/c7b9737bf41d32b2b80dfaaba4b83b3237caae
+/.git/objects/59/631287f07bbd6e06894075d7a1b44ef1bd90d2
+/.git/objects/5d/7b147a2b1a70bc90f896e209482051cac3b3e0
+/.git/objects/5f/d0d49fc87a408e940f89257a84e42fd26db3f2
+/.git/objects/61/906e850d3f83444507ecdc1fb9e085222104b5
+/.git/objects/67/ddd10fe349dc2acf922eea2b4a3e4fa5ea9429
+/.git/objects/68/5ce9f76ca15d09cf6e1be3e02b1a75ed9ad67d
+/.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc
+/.git/objects/6b/44ad28de6abbea42fc01b18dce452103d9e7f6
+/.git/objects/6b/5cf7797e750cc6bfa17f8e214898cc20423a3f
+/.git/objects/6b/9b0a44c59f31c1431e5570954d90fdd726418d
+/.git/objects/6c/246424f93893cd073f3d1bd7f636fcdf2a8f6b
+/.git/objects/6c/f072a973f0e9b5df5708bc22f87d48cea5f3c0
+/.git/objects/6e/32fb5b36fb51d2d009519c061beb1b92f7b568
+/.git/objects/6e/43436847378f923cf6d07ac36edb0b7c6d94b6
+/.git/objects/6f/21b8c406d74ee4404188aab137e27a3ad825af
+/.git/objects/6f/f8fa664f641464a3c3a5680c2fc82cef12381f
+/.git/objects/71/411d71fbf4bcfaa03b646fa35c27d996f9d52e
+/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+/.git/objects/77/2704d8527483dc9bd3881838b5ae736e6a3080
+/.git/objects/7a/f0745ca3fa03f03d1553a4c3cdfb74644f9e67
+/.git/objects/7e/d0b31d9dbdcdd0e1f796f94a8a0edee9188f76
+/.git/objects/7f/1d432fbe858693e07e0f8841e84c792af2031d
+/.git/objects/7f/b0d4d339e78998d525baf7d47c1bb8a7ee05de
+/.git/objects/80/22bc8bdf4cb285c65c6e05758f2a53a2a19be6
+/.git/objects/80/2c90f38a670110c5b39e678067d43aa56af5f8
+/.git/objects/85/ce4526c7499f9d59944e1e006278d669c09343
+/.git/objects/87/616f238482a6137fa0e9ecf3b29a47e08ba574
+/.git/objects/88/ecd90b14e8bd5850f801f539c4edeec367a1ad
+/.git/objects/8d/2d97a18f77e17c906c6f06e314308254d3014d
+/.git/objects/8e/5fca5fd0d4a83341928232bebb03ddc063fa39
+/.git/objects/90/c179d86e49e8f9cb01f9f441c21477b64b8cd8
+/.git/objects/91/69f879d5c8964f429329cacbb228d900a0f368
+/.git/objects/93/a9ff49344da6ca9b0bc1754a35a8642b385561
+/.git/objects/96/3aff0b633cf34ac705e22de6d5f7052727ebd4
+/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+/.git/objects/97/b899881080136b7329ecccd6a8ff2462d5241b
+/.git/objects/9a/6474cc575269218262e5befaf996589b4b0725
+/.git/objects/a1/68398a440f4c5345b3b3565e9f86f87edab677
+/.git/objects/a4/2329826914d12946dca5006a756bd71d2e40a6
+/.git/objects/a5/c96ae3c6227dc41e4ec78126f6331112f18d28
+/.git/objects/a8/e2b1bf7684eb227f451507d3a2426bfe896c8f
+/.git/objects/a9/7e1ab2919f0342e08b4871f42597fc25cba4ac
+/.git/objects/a9/cfc582bac4e2f77cb3a782cce2276797e3cf6d
+/.git/objects/aa/89a00b93e7cebdbd94d5acb4d83d98a3d23ae4
+/.git/objects/ac/0a3f4ff245717751593bf94456a23062670281
+/.git/objects/ac/14d6758736a7039859e268380d59a3b326b399
+/.git/objects/b2/3b264149f35fafc61fc64e209a58ec653e8560
+/.git/objects/b9/b281651bbdd7a26d9a588cfec35c0470aa921b
+/.git/objects/be/bbdf2844f2f1e3a5f33e187b312baa769c280a
+/.git/objects/bf/b3e39173d53801417602636de619113423353a
+/.git/objects/c0/6c06bae75f4eadb6f3b484daaf0df95379fea0
+/.git/objects/c1/c4ebd69aa9312836630aa6b99ca0252ee2f0ae
+/.git/objects/c2/fdd0799e3b7cf389c83410273861f583ae8716
+/.git/objects/c3/e53b84164752b49157a170c31cc7533f5d2fee
+/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+/.git/objects/c9/37f78182ddde0206560e0e602788143fdb5b9d
+/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+/.git/objects/cd/5da4c8fba2eb39aace10ad59a84be6d094862d
+/.git/objects/d0/16713dfcdd945a90764e59637156e4e77b239a
+/.git/objects/d0/59b6e9c195a2a7ce448272efd11719d3715c61
+/.git/objects/d0/a590a1e82da3c72a9484491b61e6bccaf4b6e3
+/.git/objects/d0/d5683a4b63386ff54b787640fcf8c1e9ce605b
+/.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78
+/.git/objects/d1/cbca8c4639e7e89c458a3c273f0acebd9ebe1a
+/.git/objects/d2/0302c9b0f578ec42967969e2892bc4416d66ca
+/.git/objects/d5/62bfa38c545099391ee84f30644aca5c4e04a3
+/.git/objects/d6/81f37c2ad71d1a24bfccf5c039cb90a8b74b6e
+/.git/objects/da/116ccca88cede3c380ac4f2910e7fbfec3c98c
+/.git/objects/de/8b77f039b60bc7ef5ca03a85e9712c734fb3c0
+/.git/objects/df/54c5a865dbf20b853a1e12c04a01c76b3a9285
+/.git/objects/df/ab375b6db323649427d9b468018424e7b318ad
+/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+/.git/objects/e7/0c3da4a581efea1f3c3cecbcadf932c80ee641
+/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+/.git/objects/ea/f2034dc4702cda5cdea9276aa329109efd76f1
+/.git/objects/eb/02039079a5e73413c80696c73153fca1810484
+/.git/objects/f1/3b51941ba05149023344e796411aa0c6a438cb
+/.git/objects/f1/7257c6cddd76fb6c04620a5cca5065726c7022
+/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+/.git/objects/f3/e544736920f9d8e349dae1185582ef78300898
+/.git/objects/f4/a9130b95f1231b86c72ef6d1ce3c3c8198905e
+/.git/objects/f5/4b8fcefc1c6a57a32eb9779db43168b0186fe0
+/.git/objects/f6/07a662cc46985756ea5b4f041dc23347f24769
+/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+/.git/objects/fc/ccbf936220654899cea62a94163562ca9ebcef
+/.git/objects/fc/cd7f38f6769c6fc941db1b04fa52f06088c55b
+/.git/HEAD
+/.git/index
+/.git/config
+/.git/ORIG_HEAD
+/.git/FETCH_HEAD
+/.git/description
+/.git/COMMIT_EDITMSG
+/.log/history.log
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_8_24_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__8_24_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__1_50_PM__Default_.xml
+/.idea/copyright/profiles_settings.xml
+/.idea/libraries/algs4.xml
+/.idea/libraries/stdlib.xml
+/.idea/.name
+/.idea/vcs.xml
+/.idea/misc.xml
+/.idea/modules.xml
+/.idea/compiler.xml
+/.idea/workspace.xml
+/.idea/uiDesigner.xml
+/tests/.donotlog
+/tests/png2emap.py
+/tests/ramp.png.emap
+/tests/ramp2.png.emap
+/tests/ramp3.png.emap
+/tests/mazeAB.png.emap
+/tests/usa128.png.emap
+/tests/usa256.png.emap
+/tests/usa1024.png.emap
+/tests/maze32_0.png.emap
+/tests/maze32_1.png.emap
+/tests/maze232_0.png.emap
+/tests/maze320_0.png.emap
+/tests/mazeBrain.png.emap
+/.cos265
+/readme.html
+/P04_Pathfinding.iml
+
+--[ 2022.11.03.16.14.42.363.0 ]--
+InitFile: /src/Walker.java
+import java.util.Iterator;
+
+/**
+ * Walker takes an Iterable of Coords and simulates an individual
+ * walking along the path over the given Terrain
+ */
+public class Walker {
+
+    // terrain: the Terrain the Walker traverses
+    // path: the sequence of Coords the Walker follows
+    public Walker(Terrain terrain, Iterable<Coord> path) {
+    }
+
+    // returns the Walker's current location
+    public Coord getLocation() {
+        return null;
+    }
+
+    // returns true if Walker has reached the end Coord (last in path)
+    public boolean doneWalking() {
+        return true;
+    }
+
+    // advances the Walker along path
+    // byTime: how long the Walker should traverse (may be any non-negative value)
+    public void advance(float byTime) {
+    }
+
+}
+
+--[ 2022.11.03.16.14.42.364.0 ]--
+InitFile: /src/Coord.java
+/**
+ * Coordinates is an immutable type that store the tuple (i, j)
+ */
+public final class Coord {
+    private final int i;
+    private final int j;
+
+    public Coord(int i, int j) {
+        this.i = i;
+        this.j = j;
+    }
+
+    public int getI() { return i; }
+    public int getJ() { return j; }
+
+    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
+        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
+    }
+    public boolean isInBounds(Coord min, Coord max) {
+        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
+    }
+
+    public Coord add(int addI, int addJ) {
+        return new Coord(i + addI, j + addJ);
+    }
+    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }
+
+    public String toString() { return "(" + i + "," + j + ")"; }
+
+    public boolean equals(Object o) {
+        if(this == o) return true;
+        if(o == null) return false;
+        if(o.getClass() != this.getClass()) return false;
+        Coord that = (Coord) o;
+        if(this.i != that.i) return false;
+        if(this.j != that.j) return false;
+        return true;
+    }
+}
+
+--[ 2022.11.03.16.14.42.364.1 ]--
+InitFile: /src/InteractivePathfinderVisualizer.java
+import java.awt.event.KeyEvent;
+//kate was here
+/**
+ * InteractivePathfinderVisualizer visualizes the terrain and the computed
+ * path and allows the user to change parameters of the Pathfinder.  Below
+ * is a list of commands and what they do.  Note: some of the commands
+ * modify the properties of the path finder and some modify the terrain.
+ *
+ * Command        Action                                      Terrain
+ * C              clear path
+ * space          recompute path
+ * S/E            set start/end location to mouse
+ * left/right     halve/double path search heuristic value
+ * 0/1            set path search heuristic to 0 or 1
+ * W              start a walker to show the path
+ * R              randomly generate a new terrain                *
+ * M              smooths terrain under mouse                    *
+ * shift+M        smooths all terrain                            *
+ * up/down        increase/decrease terrain under mouse          *
+ */
+
+public class InteractivePathfinderVisualizer {
+    private final static int DELAY = 10;
+
+    // sets how many redraws it should take for the walker to reach its destination
+    private final static float STEPS_TO_WALK = 100.0f;
+
+    // for convenience, here are the emap files that are located under heightmaps/ folder
+    // the python script in that folder converts png files to emap. \
+    // you can use it to create your own maps to test your code
+    private final static String[] emaps = {
+            "maze32_0.png.emap",    // 0   (32x32 maze)
+            "maze32_1.png.emap",    // 1   (another 32x32 maze)
+            "maze232_0.png.emap",   // 2   (232x232 maze)
+            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
+            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
+            "mazeBrain.png.emap",   // 5   (...)
+            "ramp.png.emap",        // 6   (some tests)
+            "ramp2.png.emap",       // 7   (...)
+            "ramp3.png.emap",       // 8   (...)
+            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
+            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
+            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
+    };
+
+    private final static String emapFilename = emaps[2];        // change index to load a different elevation map
+
+
+
+    public static void main(String[] args) {
+        Terrain terrain = new Terrain(emapFilename);
+        Pathfinder pf = new Pathfinder(terrain);
+        int N = terrain.getN();
+
+        StdDraw.show(0);
+
+        // set default starting and ending locations
+        pf.setPathStart(new Coord(1, 1));
+        pf.setPathEnd(new Coord(N-3, N-3));
+
+        // find a path
+        pf.resetPath();
+        pf.computePath();
+
+        PathfinderVisualizer.draw(terrain, pf, null, N);
+        StdDraw.show(DELAY);
+
+        // prevent repeated applications
+        boolean keyboardR = false;
+        boolean keyboardM = false;
+
+        Walker walker = null;
+
+        while(true) {
+            boolean recompute = false;
+            boolean redraw = false;
+
+            // mouse location on map
+            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
+            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
+            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
+                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
+                float m = keyboardLeft ? 0.5f : 2.0f;
+                float h = pf.getHeuristic() * m;
+                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
+                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
+                float h = keyboard0 ? 0 : 1;
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
+                pf.resetPath();
+                walker = null;
+                redraw = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
+                TerrainEditor.setFractalHeights(terrain);
+                TerrainEditor.clampHeights(terrain);
+                recompute = true;
+            }
+            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
+                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
+                    if(!keyboardM) {
+                        TerrainEditor.smoothHeights(terrain);
+                        recompute = true;
+                    }
+                } else {
+                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
+                    recompute = true;
+                }
+            }
+            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
+                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
+                float add = keyboardUp ? 8.0f : -8.0f;
+                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
+                pf.setPathStart(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
+                pf.setPathEnd(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
+                Iterable<Coord> path = pf.getPathSolution();
+                if(path != null) {
+                    walker = new Walker(terrain, pf.getPathSolution());
+                }
+            }
+
+            if(walker != null) {
+                if(walker.doneWalking()) {
+                    walker = null;
+                } else {
+                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
+                }
+                redraw = true;
+            }
+
+            if(recompute) {
+                walker = null;
+                pf.resetPath();
+                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
+                    pf.computePath();
+                }
+                redraw = true;
+            }
+
+            if(redraw) {
+                PathfinderVisualizer.draw(terrain, pf, walker, N);
+                StdDraw.show(DELAY);
+            } else {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    /* do nothing */
+                }
+            }
+        }
+    }
+}
+
+--[ 2022.11.03.16.14.42.366.0 ]--
+InitFile: /src/Terrain.java
+import java.lang.IndexOutOfBoundsException;
+
+/**
+ * Terrain stores elevations for map and computes distance and
+ * cost in traversing the terrain.
+ */
+
+public class Terrain {
+    private int N;
+    private int[][] heights;
+
+    public Terrain(int N) {
+        this.N = N;
+        this.heights = new int[N][N];
+    }
+
+    public Terrain(int[][] heights) {
+        this.N = heights.length;
+        this.heights = heights;
+    }
+
+    public Terrain(String emapfile) {
+        In in = new In(emapfile);
+        this.N = in.readInt();
+        this.heights = new int[N][N];
+        for (int j = 0; j < N; j++) {
+            for (int i = 0; i < N; i++) {
+                this.heights[i][j] = in.readInt();
+            }
+        }
+    }
+
+    public int getN() {
+        return N;
+    }
+
+    public void setHeight(int i, int j, int h) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        heights[i][j] = h;
+    }
+    public void setHeight(int i, int j, float h) {
+        setHeight(i, j, (int) h);
+    }
+    public void setHeight(Coord loc, int h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+    public void setHeight(Coord loc, float h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+
+    public int getHeight(int i, int j) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        return heights[i][j];
+    }
+    public int getHeight(Coord loc) {
+        return getHeight(loc.getI(), loc.getJ());
+    }
+
+    // computes distance between (i0,j0) and (i1,j1) as the crow flies
+    public float computeDistance(int i0, int j0, int i1, int j1) {
+        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+    }
+    public float computeDistance(Coord c0, Coord c1) {
+        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+
+    public float computeTravelCost(int i0, int j0, int i1, int j1) {
+        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
+        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
+        float dist = computeDistance(i0,j0, i1,j1);
+        return (1.0f + climb) * dist;
+    }
+    public float computeTravelCost(Coord c0, Coord c1) {
+        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+    public float computeTravelCost(Iterable<Coord> cs) {
+        Coord c0 = null;
+        float cost = 0.0f;
+        for(Coord c1 : cs) {
+            if(c0 != null) cost += computeTravelCost(c0, c1);
+            c0 = c1;
+        }
+        return cost;
+    }
+}
+
+--[ 2022.11.03.16.14.42.367.0 ]--
+InitFile: /.cos265
+
+
+--[ 2022.11.03.16.14.42.368.0 ]--
+InitFile: /src/TerrainEditor.java
+/**
+ * The following class provides some simple terrain editing functions.
+ */
+public class TerrainEditor {
+    private static float rndRadius(float d) {
+        return (float)StdRandom.uniform(-d,d);
+    }
+
+    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
+        int N = terrain.getN();
+        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
+        if(!isset[i + j * N]) {
+            isset[i + j * N] = true;
+            terrain.setHeight(i, j, dh);
+        }
+        return terrain.getHeight(i,j);
+    }
+
+    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
+        int id = i1-i0;
+        int jd = j1-j0;
+        int i01 = (i0+i1)/2;
+        int j01 = (j0+j1)/2;
+
+        if(id <= 1 && jd <= 1) return;
+
+        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
+        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
+        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
+        float h11 = getFractalHeight(i1,j1,32,terrain,isset);
+
+        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);
+
+        float d0001 = (h00 + h01) / 2 + rndRadius(d);
+        float d0010 = (h00 + h10) / 2 + rndRadius(d);
+        float d1101 = (h11 + h01) / 2 + rndRadius(d);
+        float d1110 = (h11 + h10) / 2 + rndRadius(d);
+
+        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
+        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
+        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
+        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);
+
+        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
+        float hm = getFractalHeight(i01, j01, dm, terrain,isset);
+
+        if(id > 1 && jd > 1) {
+            setFractalHeights(i0, j0, i01, j01, terrain, isset);
+            setFractalHeights(i01, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i01, j1, terrain, isset);
+            setFractalHeights(i01, j01, i1, j1, terrain, isset);
+        } else if(jd > 1) {
+            setFractalHeights(i0, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i1, j1, terrain, isset);
+        } else {
+            setFractalHeights(i0, j0, i01, j1, terrain, isset);
+            setFractalHeights(i01, j0, i1, j1, terrain, isset);
+        }
+    }
+
+    public static void setFractalHeights(Terrain terrain) {
+        int N = terrain.getN();
+        boolean[] isset = new boolean[N*N];
+        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
+    }
+
+    public static void smoothHeights(Terrain terrain) {
+        int N = terrain.getN();
+        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
+        smoothHeights(N/2, N/2, radius, false, terrain);
+    }
+
+    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
+        final int N = terrain.getN();
+        final int w = 2*radius+1;
+        float[] s = new float[w*w];
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+
+                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
+                if(m <= 0.0000001) {
+                    s[sidx] = terrain.getHeight(i,j);
+                    continue;
+                }
+                float h = 0;
+                int c = 0;
+                if(i > 0 && j > 0) {
+                    h += terrain.getHeight(i-1,j-1);
+                    c += 1;
+                }
+                if(i < N-1 && j > 0) {
+                    h += terrain.getHeight(i+1,j-1);
+                    c += 1;
+                }
+                if(i > 0 && j < N-1) {
+                    h += terrain.getHeight(i-1,j+1);
+                    c += 1;
+                }
+                if(i < N-1 && j < N-1) {
+                    h += terrain.getHeight(i+1,j+1);
+                    c += 1;
+                }
+                if(i > 0) {
+                    h += terrain.getHeight(i-1,j);
+                    c += 1;
+                }
+                if(j > 0) {
+                    h += terrain.getHeight(i,j-1);
+                    c += 1;
+                }
+                if(i < N-1) {
+                    h += terrain.getHeight(i+1,j);
+                    c += 1;
+                }
+                if(j < N-1) {
+                    h += terrain.getHeight(i,j+1);
+                    c += 1;
+                }
+                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
+            }
+        }
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+                terrain.setHeight(i, j, s[sidx]);
+            }
+        }
+    }
+
+    public static void clampHeights(Terrain terrain) {
+        int N = terrain.getN();
+        for(int i = 0; i < N; i++) {
+            for(int j = 0; j < N; j++) {
+                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
+            }
+        }
+    }
+
+    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
+        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
+        if(!fallOff) return 1;
+        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
+        if(d2 > radius*radius) return 0;
+        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
+    }
+
+    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
+        final int N = terrain.getN();
+        for(int ja = -radius; ja <= radius; ja++) {
+            int r = j + ja;
+            if(r < 0 || r >= N) continue;
+            for(int ia = -radius; ia <= radius; ia++) {
+                int c = i + ia;
+                if(c < 0 || c >= N) continue;
+                float v = add * computeEffect(c, r, i, j, radius, true, N);
+                float h = terrain.getHeight(c, r) + v;
+                h = Math.max(0, Math.min(255, h));
+                terrain.setHeight(c, r, h);
+            }
+        }
+    }
+}
+
+--[ 2022.11.03.16.14.42.368.1 ]--
+InitFile: /P04_Pathfinding.iml
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.log" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="algs4" level="project" />
+    <orderEntry type="library" name="stdlib" level="project" />
+  </component>
+</module>
+
+--[ 2022.11.03.16.14.42.369.0 ]--
+InitFile: /src/PathfinderVisualizer.java
+/**
+ * PathfinderVisualizer visualizes the terrain and found path.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+
+public class PathfinderVisualizer {
+
+    // delay in milliseconds (controls animation speed)
+    private final static int DELAY = 100;
+
+    // color for different elevations.  must be in ascending order!
+    private final static int[][] elevationColors = {
+            // h    r   g   b   where h=height, r=red, g=green, b=blue
+            {  0,   0,  0,  0},
+            {  2,   0,  0,160},
+            {  4,   0,224,224},
+            { 16, 192,192,  0},
+            { 64,  16,255, 16},
+            {128,  32,224, 32},
+            {192, 128,128,  8},
+            {224, 164,164,164},
+            {255, 255,255,255}
+    };
+
+    private final static Color cStart    = new Color(128, 128, 255);
+    private final static Color cEnd      = new Color(255, 128, 128);
+    private final static Color cSolution = new Color(255, 128, 255);
+    private final static Color cSearched = new Color(128,   0, 128);
+
+    // linearly interpolating between the corresponding rgb values
+    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * r0 + v1 * r1);
+        int g = (int)(v0 * g0 + v1 * g1);
+        int b = (int)(v0 * b0 + v1 * b1);
+        return new Color(r, g, b);
+    }
+    private static Color colorLERP(float v1, Color c0, Color c1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
+        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
+        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
+        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
+        return new Color(r, g, b, a);
+    }
+
+    // returns color for given height
+    private static Color height2Color(int h) {
+        h = Math.max(0, Math.min(255, h));
+
+        int[] ec0 = elevationColors[0];  // default lower bound
+        int[] ec1 = elevationColors[1];  // default upper bound
+
+        // find upper bound while updating lower bound
+        for(int i = 1; i < elevationColors.length; i++) {
+            ec1 = elevationColors[i];
+            if(h >= ec0[0] && h <= ec1[0]) break;
+            ec0 = ec1;
+        }
+
+        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
+        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
+        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));
+
+        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
+    }
+
+    private static void drawCircle(int i, int j, int N, double rad) {
+        int c = (int)((i+0.5f) * 464.0f / N);
+        int r = (int)((j+0.5f) * 464.0f / N);
+        StdDraw.circle(c + 24, 464 - r + 36, rad);
+    }
+    public static void drawCircle(Coord loc, int N, double rad) {
+        drawCircle(loc.getI(), loc.getJ(), N, rad);
+    }
+
+    private static void drawPath(Iterable<Coord> path, int N) {
+        boolean first = true;
+        int c0 = 0, r0 = 0;
+        for (Coord loc : path) {
+            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
+            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
+            if(!first) {
+                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
+            }
+            first = false;
+            c0 = c1; r0 = r1;
+        }
+    }
+
+    // draw N-by-N pathfinding map
+    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
+        StdDraw.clear();
+        StdDraw.setXscale(0, 512);
+        StdDraw.setYscale(0, 512);
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.filledSquare(256, 256 + 12, 464 / 2);
+
+        // draw terrain
+        for(int row = 0; row < 464; row++) {
+            int j = (int)((float)row/464.0f * N);
+            for(int col = 0; col < 464; col++) {
+                int i = (int)((float)col/464.0f * N);
+                Coord loc = new Coord(i,j);
+                Color c = height2Color(terrain.getHeight(loc));
+                if(pf.wasSearched(loc)) {
+                    c = colorLERP(0.50f, c, cSearched);
+                }
+                StdDraw.setPenColor(c);
+                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
+            }
+        }
+
+        // draw path start
+        if(pf.getPathStart() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathStart(), N, 4.0);
+
+            StdDraw.setPenColor(cStart);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathStart(), N, 4.0);
+        }
+
+        // draw path end
+        if(pf.getPathEnd() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+
+            StdDraw.setPenColor(cEnd);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+        }
+
+        // draw found path
+        if(pf.foundPath()) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawPath(pf.getPathSolution(), N);
+
+            StdDraw.setPenColor(cSolution);
+            StdDraw.setPenRadius(0.002);
+            drawPath(pf.getPathSolution(), N);
+        }
+
+        // draw walker
+        if(walker != null) {
+            Coord loc = walker.getLocation();
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+
+            StdDraw.setPenColor(StdDraw.WHITE);
+            StdDraw.setPenRadius(0.002);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+        }
+
+        // write status text
+        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
+        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
+        else               StdDraw.text(256, 12, "no path found");
+        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
+    }
+}
+
+--[ 2022.11.03.16.14.42.373.0 ]--
+InitFile: /src/Pathfinder.java
+import java.lang.IndexOutOfBoundsException;
+import java.lang.IllegalArgumentException;
+
+/**
+ * Pathfinder uses A* search to find a near optimal path
+ * between to locations with given terrain.
+ */
+//hiiiiiiiiiiii
+    //this is Makayla...
+public class Pathfinder {
+
+    /**
+     * PFNode will be the key for MinPQ (used in computePath())
+     */
+    private class PFNode implements Comparable<PFNode> {
+        // loc: the location of the PFNode
+        // fromNode: how did we get here? (linked list back to start)
+        Coord location;
+        PFNode previous;
+        float cost;
+        public PFNode(Coord loc, PFNode fromNode, float newCost) {
+           location=loc;
+           previous=fromNode;
+           cost=newCost;
+        }
+
+        // compares this with that, used to find minimum cost PFNode
+        public int compareTo(PFNode that) {
+            return this.compareTo(that);
+        }
+
+        // returns the cost to travel from starting point to this
+        // via the fromNode chain
+        public float getCost(float heuristic) {
+
+            return 0;
+        }
+
+        // returns if this PFNode is still valid
+        public boolean isValid() {
+            return false;
+        }
+
+        // invalidates the PFNode
+        public void invalidate() {
+        }
+
+        // returns if the PFNode has been used
+        public boolean isUsed() {
+            return true;
+        }
+
+        // uses the PFNode
+        public void use() { }
+
+        // returns an Iterable of PFNodes that surround this
+        public Iterable<PFNode> neighbors() {
+            Stack<PFNode> s = new Stack<>();
+            s.push(new PFNode(null, null, 0));
+            return s;
+        }
+    }
+
+    public Pathfinder(Terrain terrain) {
+    }
+    Coord pathStart=null;
+    Coord pathEnd=null;
+    float heuristic = 1;
+    boolean pathFound=false;
+    public void setPathStart(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathStart=loc;
+    }
+
+    public Coord getPathStart() { // this function is a little redundant if we
+                                  // just have a global var for it anyway...
+        return pathStart;
+    }
+
+    public void setPathEnd(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathEnd=loc;
+    }
+
+    public Coord getPathEnd() {
+        return pathEnd;
+    }
+
+    public void setHeuristic(float v) {
+        heuristic=v;
+    }
+
+    public float getHeuristic() {
+        return heuristic;
+    }
+
+    //cleans out the queues ??
+    public void resetPath() {
+    }
+
+    public void computePath() {
+        // make the priorety queue
+        Terrain map = new Terrain("maze232_0.png.emap");
+        MinPQ<PFNode> PQ = new MinPQ<>();
+        PFNode start = new PFNode(pathStart, null, 0);
+        PQ.insert(start);
+        while (!pathFound) {
+            PFNode location = PQ.delMin();
+
+            if (location.location == pathEnd) {    //if the location is the end
+                pathFound = true;
+                return;
+            }
+
+            if (location == null) return;
+
+            Coord[] neighbourList = checkNeighbour(location.location);  //give all the neighbours
+            float previousCost = location.cost;
+            for (int i = 0; i < 4; i++) {
+                float cost = map.computeTravelCost(location.location, neighbourList[i]);
+                PFNode temp = new PFNode(neighbourList[i], location, cost);
+                PQ.insert(temp);
+            }
+        }
+    }
+
+    private Coord[] checkNeighbour(Coord loc){
+        int x = loc.getI();   //row
+        int y = loc.getJ();   //col
+
+        Coord[] neighbourList = new Coord[4];
+        neighbourList[0] = loc.add(0, 1);   //up
+        neighbourList[1] = loc.add(-1, 0);  //left
+        neighbourList[2] = loc.add(0, -1);  //down
+        neighbourList[3] = loc.add(1, 0);   //right
+
+        //edge cases
+
+        return neighbourList;
+
+    }
+
+    public boolean foundPath() {
+        return pathFound;
+    }
+
+    public float getPathCost() {
+        return 0;
+    }
+
+    public int getSearchSize() {
+        return 0;
+    }
+
+    public Iterable<Coord> getPathSolution() {
+        return null;
+    }
+
+    public boolean wasSearched(Coord loc) {
+        return false;
+    }
+}
+
+--[ 2022.11.03.17.35.01.810.0 ]--
+DisposeComponent
+--[ 2022.11.03.20.33.43.351.0 ]--
+NewLogger: P04_Pathfinding
+Version: 1.5
+--[ 2022.11.03.20.33.43.743.0 ]--
+InitTree:
+/out/production/P04_Pathfinding/.donotlog
+/out/production/P04_Pathfinding/algs4.jar
+/out/production/P04_Pathfinding/stdlib.jar
+/out/production/P04_Pathfinding/Coord.class
+/out/production/P04_Pathfinding/png2emap.py
+/out/production/P04_Pathfinding/Walker.class
+/out/production/P04_Pathfinding/ramp.png.emap
+/out/production/P04_Pathfinding/Terrain.class
+/out/production/P04_Pathfinding/ramp2.png.emap
+/out/production/P04_Pathfinding/ramp3.png.emap
+/out/production/P04_Pathfinding/mazeAB.png.emap
+/out/production/P04_Pathfinding/usa128.png.emap
+/out/production/P04_Pathfinding/usa256.png.emap
+/out/production/P04_Pathfinding/Pathfinder.class
+/out/production/P04_Pathfinding/usa1024.png.emap
+/out/production/P04_Pathfinding/maze32_0.png.emap
+/out/production/P04_Pathfinding/maze32_1.png.emap
+/out/production/P04_Pathfinding/maze232_0.png.emap
+/out/production/P04_Pathfinding/maze320_0.png.emap
+/out/production/P04_Pathfinding/mazeBrain.png.emap
+/out/production/P04_Pathfinding/TerrainEditor.class
+/out/production/P04_Pathfinding/Pathfinder$PFNode.class
+/out/production/P04_Pathfinding/PathfinderVisualizer.class
+/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+/src/algs4.jar
+/src/Coord.java
+/src/stdlib.jar
+/src/Walker.java
+/src/Terrain.java
+/src/Pathfinder.java
+/src/TerrainEditor.java
+/src/PathfinderVisualizer.java
+/src/InteractivePathfinderVisualizer.java
+/.git/info/exclude
+/.git/logs/refs/heads/main
+/.git/logs/refs/remotes/origin/main
+/.git/logs/HEAD
+/.git/refs/heads/main
+/.git/refs/remotes/origin/main
+/.git/hooks/update.sample
+/.git/hooks/pre-push.sample
+/.git/hooks/commit-msg.sample
+/.git/hooks/pre-commit.sample
+/.git/hooks/pre-rebase.sample
+/.git/hooks/post-update.sample
+/.git/hooks/pre-receive.sample
+/.git/hooks/applypatch-msg.sample
+/.git/hooks/pre-applypatch.sample
+/.git/hooks/pre-merge-commit.sample
+/.git/hooks/push-to-checkout.sample
+/.git/hooks/fsmonitor-watchman.sample
+/.git/hooks/prepare-commit-msg.sample
+/.git/objects/00/83268a14a16b4a5dd867518f78733391a45c17
+/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+/.git/objects/02/b01225b71d3414a2e2cc73cafd334173831774
+/.git/objects/08/03327110344bdd9225216d43717854bdcb5a02
+/.git/objects/0a/0cc74c3c69529bc0b35efec4b33b4122f3f9d2
+/.git/objects/0a/223ed78fd4ba9e3c29d48824487e673a123de6
+/.git/objects/11/96e8a2e363c7dabd777bfe6bc8bd9c4f24983d
+/.git/objects/11/f974299e37fea0743352c5bb44bd670176a9c4
+/.git/objects/12/b0c09257d01178df8b7f1060740432172d7b42
+/.git/objects/13/ac099b7d719505f83e4bcc7f8d3e3324233f0e
+/.git/objects/14/1a3f4b2369df3af5a953caed0c4cab5f978deb
+/.git/objects/14/98d3ed54fd6d24a517dbb6edfdb89592a3a42f
+/.git/objects/17/9f9a625eb41082f81a6ba399335a590c13065d
+/.git/objects/19/758b3cfb8d02709de9b698387494c8b840197a
+/.git/objects/19/8f86a451262bb58f20fec4b4372511d319cb1e
+/.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9
+/.git/objects/1d/9870f3870280622cc38ff3a0db5d362720a2c9
+/.git/objects/1d/ba1a0866ebec020b4fff86ea9bec07c9be5f9c
+/.git/objects/1e/1b111e44a3392c3dc2f8c9e8466a2caa4c87f1
+/.git/objects/21/86213986a340219401746588209691c3a095a9
+/.git/objects/22/d1da271c9ad5057fed4e6702f0c556345d4b1e
+/.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1
+/.git/objects/29/3bba6c1d610b4ce86b15d1a807bfd9512e1e31
+/.git/objects/2e/c358f7bcf4f758b64b2f2d516d8aadd28268c4
+/.git/objects/2f/8959443fe58250b1251ba5223cef6fae049f6a
+/.git/objects/2f/9b1b9136e49f3aa4604e0907ea0497bd459bc9
+/.git/objects/30/27eb765074649989e38ee5953c045f541f2514
+/.git/objects/31/0e1d1baa102c6827797e192b38e3f6d8629fc6
+/.git/objects/31/fd9bbe5bb6e815ef3de6539321474dc6aec3b3
+/.git/objects/33/ebf301bb19589b3acf4d18d1fc9bd8f90302f4
+/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+/.git/objects/35/21629ecf5199e7d9a5a177d2937d17e36b73d3
+/.git/objects/36/bd4febfa8552f3cead1307339c48c6a2c9afb9
+/.git/objects/38/57c26673f53453f16ced8fe4cb6e8efd294f3a
+/.git/objects/39/122c7c3262ceff1338c9cc29fd32418783debf
+/.git/objects/3d/dd471797ab3fd4fdaa9102e86d087b9c85ae6c
+/.git/objects/3e/7c188a1be72d5f1cce5cdf5779924b039be66a
+/.git/objects/43/e81b1e944a8a3a9f9e42f72a0c1140f9633327
+/.git/objects/44/3d1398732fb006321a93e89dc6ccbcc76cefb6
+/.git/objects/46/58c672f584d326af787728f4e52bb379ffbf98
+/.git/objects/47/bfeee24fec7f21d5ff12c1c28cc444d9ddba85
+/.git/objects/49/1df43ab4b5595701f6f144d36d667d96a0a282
+/.git/objects/49/d6a74a87046e6d92d7453d56a4da013dee44ff
+/.git/objects/4a/25ed2698823ce5825bc66c5a5c767c54af7731
+/.git/objects/4d/137de7a049bcd5094c3a60d8357d28d0b68990
+/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+/.git/objects/54/d71d3d486b9af299988fade384c5fb18962bc9
+/.git/objects/55/e133c8e1aa563ba7414e9ae3501bf8306293b2
+/.git/objects/56/c7b9737bf41d32b2b80dfaaba4b83b3237caae
+/.git/objects/59/631287f07bbd6e06894075d7a1b44ef1bd90d2
+/.git/objects/5d/7b147a2b1a70bc90f896e209482051cac3b3e0
+/.git/objects/5f/d0d49fc87a408e940f89257a84e42fd26db3f2
+/.git/objects/61/906e850d3f83444507ecdc1fb9e085222104b5
+/.git/objects/67/ddd10fe349dc2acf922eea2b4a3e4fa5ea9429
+/.git/objects/68/5ce9f76ca15d09cf6e1be3e02b1a75ed9ad67d
+/.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc
+/.git/objects/6b/44ad28de6abbea42fc01b18dce452103d9e7f6
+/.git/objects/6b/5cf7797e750cc6bfa17f8e214898cc20423a3f
+/.git/objects/6b/9b0a44c59f31c1431e5570954d90fdd726418d
+/.git/objects/6c/246424f93893cd073f3d1bd7f636fcdf2a8f6b
+/.git/objects/6c/f072a973f0e9b5df5708bc22f87d48cea5f3c0
+/.git/objects/6e/32fb5b36fb51d2d009519c061beb1b92f7b568
+/.git/objects/6e/43436847378f923cf6d07ac36edb0b7c6d94b6
+/.git/objects/6f/21b8c406d74ee4404188aab137e27a3ad825af
+/.git/objects/6f/f8fa664f641464a3c3a5680c2fc82cef12381f
+/.git/objects/71/411d71fbf4bcfaa03b646fa35c27d996f9d52e
+/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+/.git/objects/77/2704d8527483dc9bd3881838b5ae736e6a3080
+/.git/objects/7a/f0745ca3fa03f03d1553a4c3cdfb74644f9e67
+/.git/objects/7e/d0b31d9dbdcdd0e1f796f94a8a0edee9188f76
+/.git/objects/7f/1d432fbe858693e07e0f8841e84c792af2031d
+/.git/objects/7f/b0d4d339e78998d525baf7d47c1bb8a7ee05de
+/.git/objects/80/22bc8bdf4cb285c65c6e05758f2a53a2a19be6
+/.git/objects/80/2c90f38a670110c5b39e678067d43aa56af5f8
+/.git/objects/85/ce4526c7499f9d59944e1e006278d669c09343
+/.git/objects/87/616f238482a6137fa0e9ecf3b29a47e08ba574
+/.git/objects/88/ecd90b14e8bd5850f801f539c4edeec367a1ad
+/.git/objects/8d/2d97a18f77e17c906c6f06e314308254d3014d
+/.git/objects/8e/5fca5fd0d4a83341928232bebb03ddc063fa39
+/.git/objects/90/c179d86e49e8f9cb01f9f441c21477b64b8cd8
+/.git/objects/91/69f879d5c8964f429329cacbb228d900a0f368
+/.git/objects/93/a9ff49344da6ca9b0bc1754a35a8642b385561
+/.git/objects/96/3aff0b633cf34ac705e22de6d5f7052727ebd4
+/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+/.git/objects/97/b899881080136b7329ecccd6a8ff2462d5241b
+/.git/objects/9a/6474cc575269218262e5befaf996589b4b0725
+/.git/objects/a1/68398a440f4c5345b3b3565e9f86f87edab677
+/.git/objects/a4/2329826914d12946dca5006a756bd71d2e40a6
+/.git/objects/a5/c96ae3c6227dc41e4ec78126f6331112f18d28
+/.git/objects/a8/e2b1bf7684eb227f451507d3a2426bfe896c8f
+/.git/objects/a9/7e1ab2919f0342e08b4871f42597fc25cba4ac
+/.git/objects/a9/cfc582bac4e2f77cb3a782cce2276797e3cf6d
+/.git/objects/aa/89a00b93e7cebdbd94d5acb4d83d98a3d23ae4
+/.git/objects/ac/0a3f4ff245717751593bf94456a23062670281
+/.git/objects/ac/14d6758736a7039859e268380d59a3b326b399
+/.git/objects/b2/3b264149f35fafc61fc64e209a58ec653e8560
+/.git/objects/b9/b281651bbdd7a26d9a588cfec35c0470aa921b
+/.git/objects/be/bbdf2844f2f1e3a5f33e187b312baa769c280a
+/.git/objects/bf/b3e39173d53801417602636de619113423353a
+/.git/objects/c0/6c06bae75f4eadb6f3b484daaf0df95379fea0
+/.git/objects/c1/c4ebd69aa9312836630aa6b99ca0252ee2f0ae
+/.git/objects/c2/fdd0799e3b7cf389c83410273861f583ae8716
+/.git/objects/c3/e53b84164752b49157a170c31cc7533f5d2fee
+/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+/.git/objects/c9/37f78182ddde0206560e0e602788143fdb5b9d
+/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+/.git/objects/cd/5da4c8fba2eb39aace10ad59a84be6d094862d
+/.git/objects/d0/16713dfcdd945a90764e59637156e4e77b239a
+/.git/objects/d0/59b6e9c195a2a7ce448272efd11719d3715c61
+/.git/objects/d0/a590a1e82da3c72a9484491b61e6bccaf4b6e3
+/.git/objects/d0/d5683a4b63386ff54b787640fcf8c1e9ce605b
+/.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78
+/.git/objects/d1/cbca8c4639e7e89c458a3c273f0acebd9ebe1a
+/.git/objects/d2/0302c9b0f578ec42967969e2892bc4416d66ca
+/.git/objects/d5/62bfa38c545099391ee84f30644aca5c4e04a3
+/.git/objects/d6/81f37c2ad71d1a24bfccf5c039cb90a8b74b6e
+/.git/objects/da/116ccca88cede3c380ac4f2910e7fbfec3c98c
+/.git/objects/de/8b77f039b60bc7ef5ca03a85e9712c734fb3c0
+/.git/objects/df/54c5a865dbf20b853a1e12c04a01c76b3a9285
+/.git/objects/df/ab375b6db323649427d9b468018424e7b318ad
+/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+/.git/objects/e7/0c3da4a581efea1f3c3cecbcadf932c80ee641
+/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+/.git/objects/ea/f2034dc4702cda5cdea9276aa329109efd76f1
+/.git/objects/eb/02039079a5e73413c80696c73153fca1810484
+/.git/objects/f1/3b51941ba05149023344e796411aa0c6a438cb
+/.git/objects/f1/7257c6cddd76fb6c04620a5cca5065726c7022
+/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+/.git/objects/f3/e544736920f9d8e349dae1185582ef78300898
+/.git/objects/f4/a9130b95f1231b86c72ef6d1ce3c3c8198905e
+/.git/objects/f5/4b8fcefc1c6a57a32eb9779db43168b0186fe0
+/.git/objects/f6/07a662cc46985756ea5b4f041dc23347f24769
+/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+/.git/objects/fc/ccbf936220654899cea62a94163562ca9ebcef
+/.git/objects/fc/cd7f38f6769c6fc941db1b04fa52f06088c55b
+/.git/HEAD
+/.git/index
+/.git/config
+/.git/ORIG_HEAD
+/.git/FETCH_HEAD
+/.git/description
+/.git/COMMIT_EDITMSG
+/.log/history.log
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_8_24_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__8_24_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__1_50_PM__Default_.xml
+/.idea/copyright/profiles_settings.xml
+/.idea/libraries/algs4.xml
+/.idea/libraries/stdlib.xml
+/.idea/.name
+/.idea/vcs.xml
+/.idea/misc.xml
+/.idea/modules.xml
+/.idea/compiler.xml
+/.idea/workspace.xml
+/.idea/uiDesigner.xml
+/tests/.donotlog
+/tests/png2emap.py
+/tests/ramp.png.emap
+/tests/ramp2.png.emap
+/tests/ramp3.png.emap
+/tests/mazeAB.png.emap
+/tests/usa128.png.emap
+/tests/usa256.png.emap
+/tests/usa1024.png.emap
+/tests/maze32_0.png.emap
+/tests/maze32_1.png.emap
+/tests/maze232_0.png.emap
+/tests/maze320_0.png.emap
+/tests/mazeBrain.png.emap
+/.cos265
+/readme.html
+/P04_Pathfinding.iml
+
+--[ 2022.11.03.20.33.43.745.0 ]--
+InitFile: /src/Walker.java
+import java.util.Iterator;
+
+/**
+ * Walker takes an Iterable of Coords and simulates an individual
+ * walking along the path over the given Terrain
+ */
+public class Walker {
+
+    // terrain: the Terrain the Walker traverses
+    // path: the sequence of Coords the Walker follows
+    public Walker(Terrain terrain, Iterable<Coord> path) {
+    }
+
+    // returns the Walker's current location
+    public Coord getLocation() {
+        return null;
+    }
+
+    // returns true if Walker has reached the end Coord (last in path)
+    public boolean doneWalking() {
+        return true;
+    }
+
+    // advances the Walker along path
+    // byTime: how long the Walker should traverse (may be any non-negative value)
+    public void advance(float byTime) {
+    }
+
+}
+
+--[ 2022.11.03.20.33.43.745.1 ]--
+InitFile: /src/Coord.java
+/**
+ * Coordinates is an immutable type that store the tuple (i, j)
+ */
+public final class Coord {
+    private final int i;
+    private final int j;
+
+    public Coord(int i, int j) {
+        this.i = i;
+        this.j = j;
+    }
+
+    public int getI() { return i; }
+    public int getJ() { return j; }
+
+    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
+        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
+    }
+    public boolean isInBounds(Coord min, Coord max) {
+        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
+    }
+
+    public Coord add(int addI, int addJ) {
+        return new Coord(i + addI, j + addJ);
+    }
+    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }
+
+    public String toString() { return "(" + i + "," + j + ")"; }
+
+    public boolean equals(Object o) {
+        if(this == o) return true;
+        if(o == null) return false;
+        if(o.getClass() != this.getClass()) return false;
+        Coord that = (Coord) o;
+        if(this.i != that.i) return false;
+        if(this.j != that.j) return false;
+        return true;
+    }
+}
+
+--[ 2022.11.03.20.33.43.746.0 ]--
+InitFile: /src/InteractivePathfinderVisualizer.java
+import java.awt.event.KeyEvent;
+//kate was here
+/**
+ * InteractivePathfinderVisualizer visualizes the terrain and the computed
+ * path and allows the user to change parameters of the Pathfinder.  Below
+ * is a list of commands and what they do.  Note: some of the commands
+ * modify the properties of the path finder and some modify the terrain.
+ *
+ * Command        Action                                      Terrain
+ * C              clear path
+ * space          recompute path
+ * S/E            set start/end location to mouse
+ * left/right     halve/double path search heuristic value
+ * 0/1            set path search heuristic to 0 or 1
+ * W              start a walker to show the path
+ * R              randomly generate a new terrain                *
+ * M              smooths terrain under mouse                    *
+ * shift+M        smooths all terrain                            *
+ * up/down        increase/decrease terrain under mouse          *
+ */
+
+public class InteractivePathfinderVisualizer {
+    private final static int DELAY = 10;
+
+    // sets how many redraws it should take for the walker to reach its destination
+    private final static float STEPS_TO_WALK = 100.0f;
+
+    // for convenience, here are the emap files that are located under heightmaps/ folder
+    // the python script in that folder converts png files to emap. \
+    // you can use it to create your own maps to test your code
+    private final static String[] emaps = {
+            "maze32_0.png.emap",    // 0   (32x32 maze)
+            "maze32_1.png.emap",    // 1   (another 32x32 maze)
+            "maze232_0.png.emap",   // 2   (232x232 maze)
+            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
+            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
+            "mazeBrain.png.emap",   // 5   (...)
+            "ramp.png.emap",        // 6   (some tests)
+            "ramp2.png.emap",       // 7   (...)
+            "ramp3.png.emap",       // 8   (...)
+            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
+            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
+            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
+    };
+
+    private final static String emapFilename = emaps[2];        // change index to load a different elevation map
+
+
+
+    public static void main(String[] args) {
+        Terrain terrain = new Terrain(emapFilename);
+        Pathfinder pf = new Pathfinder(terrain);
+        int N = terrain.getN();
+
+        StdDraw.show(0);
+
+        // set default starting and ending locations
+        pf.setPathStart(new Coord(1, 1));
+        pf.setPathEnd(new Coord(N-3, N-3));
+
+        // find a path
+        pf.resetPath();
+        pf.computePath();
+
+        PathfinderVisualizer.draw(terrain, pf, null, N);
+        StdDraw.show(DELAY);
+
+        // prevent repeated applications
+        boolean keyboardR = false;
+        boolean keyboardM = false;
+
+        Walker walker = null;
+
+        while(true) {
+            boolean recompute = false;
+            boolean redraw = false;
+
+            // mouse location on map
+            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
+            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
+            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
+                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
+                float m = keyboardLeft ? 0.5f : 2.0f;
+                float h = pf.getHeuristic() * m;
+                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
+                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
+                float h = keyboard0 ? 0 : 1;
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
+                pf.resetPath();
+                walker = null;
+                redraw = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
+                TerrainEditor.setFractalHeights(terrain);
+                TerrainEditor.clampHeights(terrain);
+                recompute = true;
+            }
+            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
+                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
+                    if(!keyboardM) {
+                        TerrainEditor.smoothHeights(terrain);
+                        recompute = true;
+                    }
+                } else {
+                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
+                    recompute = true;
+                }
+            }
+            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
+                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
+                float add = keyboardUp ? 8.0f : -8.0f;
+                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
+                pf.setPathStart(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
+                pf.setPathEnd(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
+                Iterable<Coord> path = pf.getPathSolution();
+                if(path != null) {
+                    walker = new Walker(terrain, pf.getPathSolution());
+                }
+            }
+
+            if(walker != null) {
+                if(walker.doneWalking()) {
+                    walker = null;
+                } else {
+                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
+                }
+                redraw = true;
+            }
+
+            if(recompute) {
+                walker = null;
+                pf.resetPath();
+                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
+                    pf.computePath();
+                }
+                redraw = true;
+            }
+
+            if(redraw) {
+                PathfinderVisualizer.draw(terrain, pf, walker, N);
+                StdDraw.show(DELAY);
+            } else {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    /* do nothing */
+                }
+            }
+        }
+    }
+}
+
+--[ 2022.11.03.20.33.43.746.1 ]--
+InitFile: /src/Terrain.java
+import java.lang.IndexOutOfBoundsException;
+
+/**
+ * Terrain stores elevations for map and computes distance and
+ * cost in traversing the terrain.
+ */
+
+public class Terrain {
+    private int N;
+    private int[][] heights;
+
+    public Terrain(int N) {
+        this.N = N;
+        this.heights = new int[N][N];
+    }
+
+    public Terrain(int[][] heights) {
+        this.N = heights.length;
+        this.heights = heights;
+    }
+
+    public Terrain(String emapfile) {
+        In in = new In(emapfile);
+        this.N = in.readInt();
+        this.heights = new int[N][N];
+        for (int j = 0; j < N; j++) {
+            for (int i = 0; i < N; i++) {
+                this.heights[i][j] = in.readInt();
+            }
+        }
+    }
+
+    public int getN() {
+        return N;
+    }
+
+    public void setHeight(int i, int j, int h) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        heights[i][j] = h;
+    }
+    public void setHeight(int i, int j, float h) {
+        setHeight(i, j, (int) h);
+    }
+    public void setHeight(Coord loc, int h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+    public void setHeight(Coord loc, float h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+
+    public int getHeight(int i, int j) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        return heights[i][j];
+    }
+    public int getHeight(Coord loc) {
+        return getHeight(loc.getI(), loc.getJ());
+    }
+
+    // computes distance between (i0,j0) and (i1,j1) as the crow flies
+    public float computeDistance(int i0, int j0, int i1, int j1) {
+        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+    }
+    public float computeDistance(Coord c0, Coord c1) {
+        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+
+    public float computeTravelCost(int i0, int j0, int i1, int j1) {
+        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
+        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
+        float dist = computeDistance(i0,j0, i1,j1);
+        return (1.0f + climb) * dist;
+    }
+    public float computeTravelCost(Coord c0, Coord c1) {
+        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+    public float computeTravelCost(Iterable<Coord> cs) {
+        Coord c0 = null;
+        float cost = 0.0f;
+        for(Coord c1 : cs) {
+            if(c0 != null) cost += computeTravelCost(c0, c1);
+            c0 = c1;
+        }
+        return cost;
+    }
+}
+
+--[ 2022.11.03.20.33.43.747.0 ]--
+InitFile: /.cos265
+
+
+--[ 2022.11.03.20.33.43.747.1 ]--
+InitFile: /src/TerrainEditor.java
+/**
+ * The following class provides some simple terrain editing functions.
+ */
+public class TerrainEditor {
+    private static float rndRadius(float d) {
+        return (float)StdRandom.uniform(-d,d);
+    }
+
+    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
+        int N = terrain.getN();
+        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
+        if(!isset[i + j * N]) {
+            isset[i + j * N] = true;
+            terrain.setHeight(i, j, dh);
+        }
+        return terrain.getHeight(i,j);
+    }
+
+    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
+        int id = i1-i0;
+        int jd = j1-j0;
+        int i01 = (i0+i1)/2;
+        int j01 = (j0+j1)/2;
+
+        if(id <= 1 && jd <= 1) return;
+
+        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
+        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
+        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
+        float h11 = getFractalHeight(i1,j1,32,terrain,isset);
+
+        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);
+
+        float d0001 = (h00 + h01) / 2 + rndRadius(d);
+        float d0010 = (h00 + h10) / 2 + rndRadius(d);
+        float d1101 = (h11 + h01) / 2 + rndRadius(d);
+        float d1110 = (h11 + h10) / 2 + rndRadius(d);
+
+        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
+        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
+        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
+        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);
+
+        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
+        float hm = getFractalHeight(i01, j01, dm, terrain,isset);
+
+        if(id > 1 && jd > 1) {
+            setFractalHeights(i0, j0, i01, j01, terrain, isset);
+            setFractalHeights(i01, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i01, j1, terrain, isset);
+            setFractalHeights(i01, j01, i1, j1, terrain, isset);
+        } else if(jd > 1) {
+            setFractalHeights(i0, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i1, j1, terrain, isset);
+        } else {
+            setFractalHeights(i0, j0, i01, j1, terrain, isset);
+            setFractalHeights(i01, j0, i1, j1, terrain, isset);
+        }
+    }
+
+    public static void setFractalHeights(Terrain terrain) {
+        int N = terrain.getN();
+        boolean[] isset = new boolean[N*N];
+        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
+    }
+
+    public static void smoothHeights(Terrain terrain) {
+        int N = terrain.getN();
+        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
+        smoothHeights(N/2, N/2, radius, false, terrain);
+    }
+
+    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
+        final int N = terrain.getN();
+        final int w = 2*radius+1;
+        float[] s = new float[w*w];
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+
+                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
+                if(m <= 0.0000001) {
+                    s[sidx] = terrain.getHeight(i,j);
+                    continue;
+                }
+                float h = 0;
+                int c = 0;
+                if(i > 0 && j > 0) {
+                    h += terrain.getHeight(i-1,j-1);
+                    c += 1;
+                }
+                if(i < N-1 && j > 0) {
+                    h += terrain.getHeight(i+1,j-1);
+                    c += 1;
+                }
+                if(i > 0 && j < N-1) {
+                    h += terrain.getHeight(i-1,j+1);
+                    c += 1;
+                }
+                if(i < N-1 && j < N-1) {
+                    h += terrain.getHeight(i+1,j+1);
+                    c += 1;
+                }
+                if(i > 0) {
+                    h += terrain.getHeight(i-1,j);
+                    c += 1;
+                }
+                if(j > 0) {
+                    h += terrain.getHeight(i,j-1);
+                    c += 1;
+                }
+                if(i < N-1) {
+                    h += terrain.getHeight(i+1,j);
+                    c += 1;
+                }
+                if(j < N-1) {
+                    h += terrain.getHeight(i,j+1);
+                    c += 1;
+                }
+                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
+            }
+        }
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+                terrain.setHeight(i, j, s[sidx]);
+            }
+        }
+    }
+
+    public static void clampHeights(Terrain terrain) {
+        int N = terrain.getN();
+        for(int i = 0; i < N; i++) {
+            for(int j = 0; j < N; j++) {
+                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
+            }
+        }
+    }
+
+    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
+        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
+        if(!fallOff) return 1;
+        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
+        if(d2 > radius*radius) return 0;
+        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
+    }
+
+    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
+        final int N = terrain.getN();
+        for(int ja = -radius; ja <= radius; ja++) {
+            int r = j + ja;
+            if(r < 0 || r >= N) continue;
+            for(int ia = -radius; ia <= radius; ia++) {
+                int c = i + ia;
+                if(c < 0 || c >= N) continue;
+                float v = add * computeEffect(c, r, i, j, radius, true, N);
+                float h = terrain.getHeight(c, r) + v;
+                h = Math.max(0, Math.min(255, h));
+                terrain.setHeight(c, r, h);
+            }
+        }
+    }
+}
+
+--[ 2022.11.03.20.33.43.747.2 ]--
+InitFile: /P04_Pathfinding.iml
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.log" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="algs4" level="project" />
+    <orderEntry type="library" name="stdlib" level="project" />
+  </component>
+</module>
+
+--[ 2022.11.03.20.33.43.748.0 ]--
+InitFile: /src/PathfinderVisualizer.java
+/**
+ * PathfinderVisualizer visualizes the terrain and found path.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+
+public class PathfinderVisualizer {
+
+    // delay in milliseconds (controls animation speed)
+    private final static int DELAY = 100;
+
+    // color for different elevations.  must be in ascending order!
+    private final static int[][] elevationColors = {
+            // h    r   g   b   where h=height, r=red, g=green, b=blue
+            {  0,   0,  0,  0},
+            {  2,   0,  0,160},
+            {  4,   0,224,224},
+            { 16, 192,192,  0},
+            { 64,  16,255, 16},
+            {128,  32,224, 32},
+            {192, 128,128,  8},
+            {224, 164,164,164},
+            {255, 255,255,255}
+    };
+
+    private final static Color cStart    = new Color(128, 128, 255);
+    private final static Color cEnd      = new Color(255, 128, 128);
+    private final static Color cSolution = new Color(255, 128, 255);
+    private final static Color cSearched = new Color(128,   0, 128);
+
+    // linearly interpolating between the corresponding rgb values
+    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * r0 + v1 * r1);
+        int g = (int)(v0 * g0 + v1 * g1);
+        int b = (int)(v0 * b0 + v1 * b1);
+        return new Color(r, g, b);
+    }
+    private static Color colorLERP(float v1, Color c0, Color c1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
+        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
+        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
+        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
+        return new Color(r, g, b, a);
+    }
+
+    // returns color for given height
+    private static Color height2Color(int h) {
+        h = Math.max(0, Math.min(255, h));
+
+        int[] ec0 = elevationColors[0];  // default lower bound
+        int[] ec1 = elevationColors[1];  // default upper bound
+
+        // find upper bound while updating lower bound
+        for(int i = 1; i < elevationColors.length; i++) {
+            ec1 = elevationColors[i];
+            if(h >= ec0[0] && h <= ec1[0]) break;
+            ec0 = ec1;
+        }
+
+        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
+        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
+        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));
+
+        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
+    }
+
+    private static void drawCircle(int i, int j, int N, double rad) {
+        int c = (int)((i+0.5f) * 464.0f / N);
+        int r = (int)((j+0.5f) * 464.0f / N);
+        StdDraw.circle(c + 24, 464 - r + 36, rad);
+    }
+    public static void drawCircle(Coord loc, int N, double rad) {
+        drawCircle(loc.getI(), loc.getJ(), N, rad);
+    }
+
+    private static void drawPath(Iterable<Coord> path, int N) {
+        boolean first = true;
+        int c0 = 0, r0 = 0;
+        for (Coord loc : path) {
+            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
+            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
+            if(!first) {
+                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
+            }
+            first = false;
+            c0 = c1; r0 = r1;
+        }
+    }
+
+    // draw N-by-N pathfinding map
+    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
+        StdDraw.clear();
+        StdDraw.setXscale(0, 512);
+        StdDraw.setYscale(0, 512);
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.filledSquare(256, 256 + 12, 464 / 2);
+
+        // draw terrain
+        for(int row = 0; row < 464; row++) {
+            int j = (int)((float)row/464.0f * N);
+            for(int col = 0; col < 464; col++) {
+                int i = (int)((float)col/464.0f * N);
+                Coord loc = new Coord(i,j);
+                Color c = height2Color(terrain.getHeight(loc));
+                if(pf.wasSearched(loc)) {
+                    c = colorLERP(0.50f, c, cSearched);
+                }
+                StdDraw.setPenColor(c);
+                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
+            }
+        }
+
+        // draw path start
+        if(pf.getPathStart() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathStart(), N, 4.0);
+
+            StdDraw.setPenColor(cStart);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathStart(), N, 4.0);
+        }
+
+        // draw path end
+        if(pf.getPathEnd() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+
+            StdDraw.setPenColor(cEnd);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+        }
+
+        // draw found path
+        if(pf.foundPath()) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawPath(pf.getPathSolution(), N);
+
+            StdDraw.setPenColor(cSolution);
+            StdDraw.setPenRadius(0.002);
+            drawPath(pf.getPathSolution(), N);
+        }
+
+        // draw walker
+        if(walker != null) {
+            Coord loc = walker.getLocation();
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+
+            StdDraw.setPenColor(StdDraw.WHITE);
+            StdDraw.setPenRadius(0.002);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+        }
+
+        // write status text
+        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
+        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
+        else               StdDraw.text(256, 12, "no path found");
+        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
+    }
+}
+
+--[ 2022.11.03.20.33.43.748.1 ]--
+InitFile: /src/Pathfinder.java
+import java.lang.IndexOutOfBoundsException;
+import java.lang.IllegalArgumentException;
+
+/**
+ * Pathfinder uses A* search to find a near optimal path
+ * between to locations with given terrain.
+ */
+//hiiiiiiiiiiii
+    //this is Makayla...
+public class Pathfinder {
+
+    /**
+     * PFNode will be the key for MinPQ (used in computePath())
+     */
+    private class PFNode implements Comparable<PFNode> {
+        // loc: the location of the PFNode
+        // fromNode: how did we get here? (linked list back to start)
+        Coord location;
+        PFNode previous;
+        float cost;
+        public PFNode(Coord loc, PFNode fromNode, float newCost) {
+           location=loc;
+           previous=fromNode;
+           cost=newCost;
+        }
+
+        // compares this with that, used to find minimum cost PFNode
+        public int compareTo(PFNode that) {
+            return this.compareTo(that);
+        }
+
+        // returns the cost to travel from starting point to this
+        // via the fromNode chain
+        public float getCost(float heuristic) {
+
+            return 0;
+        }
+
+        // returns if this PFNode is still valid
+        public boolean isValid() {
+            return false;
+        }
+
+        // invalidates the PFNode
+        public void invalidate() {
+        }
+
+        // returns if the PFNode has been used
+        public boolean isUsed() {
+            return true;
+        }
+
+        // uses the PFNode
+        public void use() { }
+
+        // returns an Iterable of PFNodes that surround this
+        public Iterable<PFNode> neighbors() {
+            Stack<PFNode> s = new Stack<>();
+            s.push(new PFNode(null, null, 0));
+            return s;
+        }
+    }
+
+    public Pathfinder(Terrain terrain) {
+    }
+    Coord pathStart=null;
+    Coord pathEnd=null;
+    float heuristic = 1;
+    boolean pathFound=false;
+    public void setPathStart(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathStart=loc;
+    }
+
+    public Coord getPathStart() { // this function is a little redundant if we
+                                  // just have a global var for it anyway...
+        return pathStart;
+    }
+
+    public void setPathEnd(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathEnd=loc;
+    }
+
+    public Coord getPathEnd() {
+        return pathEnd;
+    }
+
+    public void setHeuristic(float v) {
+        heuristic=v;
+    }
+
+    public float getHeuristic() {
+        return heuristic;
+    }
+
+    //cleans out the queues ??
+    public void resetPath() {
+    }
+
+    public void computePath() {
+        // make the priorety queue
+        Terrain map = new Terrain("maze232_0.png.emap");
+        MinPQ<PFNode> PQ = new MinPQ<>();
+        PFNode start = new PFNode(pathStart, null, 0);
+        PQ.insert(start);
+        while (!pathFound) {
+            PFNode location = PQ.delMin();
+
+            if (location.location == pathEnd) {    //if the location is the end
+                pathFound = true;
+                return;
+            }
+
+            if (location == null) return;
+
+            Coord[] neighbourList = checkNeighbour(location.location);  //give all the neighbours
+            float previousCost = location.cost;
+            for (int i = 0; i < 4; i++) {
+                float cost = map.computeTravelCost(location.location, neighbourList[i]);
+                PFNode temp = new PFNode(neighbourList[i], location, cost);
+                PQ.insert(temp);
+            }
+        }
+    }
+
+    private Coord[] checkNeighbour(Coord loc){
+        int x = loc.getI();   //row
+        int y = loc.getJ();   //col
+
+        Coord[] neighbourList = new Coord[4];
+        neighbourList[0] = loc.add(0, 1);   //up
+        neighbourList[1] = loc.add(-1, 0);  //left
+        neighbourList[2] = loc.add(0, -1);  //down
+        neighbourList[3] = loc.add(1, 0);   //right
+
+        //edge cases
+
+        return neighbourList;
+
+    }
+
+    public boolean foundPath() {
+        return pathFound;
+    }
+
+    public float getPathCost() {
+        return 0;
+    }
+
+    public int getSearchSize() {
+        return 0;
+    }
+
+    public Iterable<Coord> getPathSolution() {
+        return null;
+    }
+
+    public boolean wasSearched(Coord loc) {
+        return false;
+    }
+}
+
+--[ 2022.11.03.20.39.55.705.0 ]--
+DisposeComponent
+--[ 2022.11.04.11.53.15.421.0 ]--
+NewLogger: P04_Pathfinding
+Version: 1.5
+--[ 2022.11.04.11.53.15.785.0 ]--
+InitTree:
+/out/production/P04_Pathfinding/.donotlog
+/out/production/P04_Pathfinding/algs4.jar
+/out/production/P04_Pathfinding/stdlib.jar
+/out/production/P04_Pathfinding/Coord.class
+/out/production/P04_Pathfinding/png2emap.py
+/out/production/P04_Pathfinding/Walker.class
+/out/production/P04_Pathfinding/ramp.png.emap
+/out/production/P04_Pathfinding/Terrain.class
+/out/production/P04_Pathfinding/ramp2.png.emap
+/out/production/P04_Pathfinding/ramp3.png.emap
+/out/production/P04_Pathfinding/mazeAB.png.emap
+/out/production/P04_Pathfinding/usa128.png.emap
+/out/production/P04_Pathfinding/usa256.png.emap
+/out/production/P04_Pathfinding/Pathfinder.class
+/out/production/P04_Pathfinding/usa1024.png.emap
+/out/production/P04_Pathfinding/maze32_0.png.emap
+/out/production/P04_Pathfinding/maze32_1.png.emap
+/out/production/P04_Pathfinding/maze232_0.png.emap
+/out/production/P04_Pathfinding/maze320_0.png.emap
+/out/production/P04_Pathfinding/mazeBrain.png.emap
+/out/production/P04_Pathfinding/TerrainEditor.class
+/out/production/P04_Pathfinding/Pathfinder$PFNode.class
+/out/production/P04_Pathfinding/PathfinderVisualizer.class
+/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+/src/algs4.jar
+/src/Coord.java
+/src/stdlib.jar
+/src/Walker.java
+/src/Terrain.java
+/src/Pathfinder.java
+/src/TerrainEditor.java
+/src/PathfinderVisualizer.java
+/src/InteractivePathfinderVisualizer.java
+/.git/info/exclude
+/.git/logs/refs/heads/main
+/.git/logs/refs/remotes/origin/main
+/.git/logs/HEAD
+/.git/refs/heads/main
+/.git/refs/remotes/origin/main
+/.git/hooks/update.sample
+/.git/hooks/pre-push.sample
+/.git/hooks/commit-msg.sample
+/.git/hooks/pre-commit.sample
+/.git/hooks/pre-rebase.sample
+/.git/hooks/post-update.sample
+/.git/hooks/pre-receive.sample
+/.git/hooks/applypatch-msg.sample
+/.git/hooks/pre-applypatch.sample
+/.git/hooks/pre-merge-commit.sample
+/.git/hooks/push-to-checkout.sample
+/.git/hooks/fsmonitor-watchman.sample
+/.git/hooks/prepare-commit-msg.sample
+/.git/objects/00/83268a14a16b4a5dd867518f78733391a45c17
+/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+/.git/objects/02/b01225b71d3414a2e2cc73cafd334173831774
+/.git/objects/08/03327110344bdd9225216d43717854bdcb5a02
+/.git/objects/0a/0cc74c3c69529bc0b35efec4b33b4122f3f9d2
+/.git/objects/0a/223ed78fd4ba9e3c29d48824487e673a123de6
+/.git/objects/11/96e8a2e363c7dabd777bfe6bc8bd9c4f24983d
+/.git/objects/11/f974299e37fea0743352c5bb44bd670176a9c4
+/.git/objects/12/b0c09257d01178df8b7f1060740432172d7b42
+/.git/objects/13/ac099b7d719505f83e4bcc7f8d3e3324233f0e
+/.git/objects/14/1a3f4b2369df3af5a953caed0c4cab5f978deb
+/.git/objects/14/98d3ed54fd6d24a517dbb6edfdb89592a3a42f
+/.git/objects/17/9f9a625eb41082f81a6ba399335a590c13065d
+/.git/objects/19/758b3cfb8d02709de9b698387494c8b840197a
+/.git/objects/19/8f86a451262bb58f20fec4b4372511d319cb1e
+/.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9
+/.git/objects/1d/9870f3870280622cc38ff3a0db5d362720a2c9
+/.git/objects/1d/ba1a0866ebec020b4fff86ea9bec07c9be5f9c
+/.git/objects/1e/1b111e44a3392c3dc2f8c9e8466a2caa4c87f1
+/.git/objects/21/86213986a340219401746588209691c3a095a9
+/.git/objects/22/d1da271c9ad5057fed4e6702f0c556345d4b1e
+/.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1
+/.git/objects/29/3bba6c1d610b4ce86b15d1a807bfd9512e1e31
+/.git/objects/2e/c358f7bcf4f758b64b2f2d516d8aadd28268c4
+/.git/objects/2f/8959443fe58250b1251ba5223cef6fae049f6a
+/.git/objects/2f/9b1b9136e49f3aa4604e0907ea0497bd459bc9
+/.git/objects/30/27eb765074649989e38ee5953c045f541f2514
+/.git/objects/31/0e1d1baa102c6827797e192b38e3f6d8629fc6
+/.git/objects/31/fd9bbe5bb6e815ef3de6539321474dc6aec3b3
+/.git/objects/33/ebf301bb19589b3acf4d18d1fc9bd8f90302f4
+/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+/.git/objects/35/21629ecf5199e7d9a5a177d2937d17e36b73d3
+/.git/objects/36/bd4febfa8552f3cead1307339c48c6a2c9afb9
+/.git/objects/38/57c26673f53453f16ced8fe4cb6e8efd294f3a
+/.git/objects/39/122c7c3262ceff1338c9cc29fd32418783debf
+/.git/objects/3d/dd471797ab3fd4fdaa9102e86d087b9c85ae6c
+/.git/objects/3e/7c188a1be72d5f1cce5cdf5779924b039be66a
+/.git/objects/43/e81b1e944a8a3a9f9e42f72a0c1140f9633327
+/.git/objects/44/3d1398732fb006321a93e89dc6ccbcc76cefb6
+/.git/objects/46/58c672f584d326af787728f4e52bb379ffbf98
+/.git/objects/47/bfeee24fec7f21d5ff12c1c28cc444d9ddba85
+/.git/objects/49/1df43ab4b5595701f6f144d36d667d96a0a282
+/.git/objects/49/d6a74a87046e6d92d7453d56a4da013dee44ff
+/.git/objects/4a/25ed2698823ce5825bc66c5a5c767c54af7731
+/.git/objects/4d/137de7a049bcd5094c3a60d8357d28d0b68990
+/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+/.git/objects/54/d71d3d486b9af299988fade384c5fb18962bc9
+/.git/objects/55/e133c8e1aa563ba7414e9ae3501bf8306293b2
+/.git/objects/56/c7b9737bf41d32b2b80dfaaba4b83b3237caae
+/.git/objects/59/631287f07bbd6e06894075d7a1b44ef1bd90d2
+/.git/objects/5d/7b147a2b1a70bc90f896e209482051cac3b3e0
+/.git/objects/5f/d0d49fc87a408e940f89257a84e42fd26db3f2
+/.git/objects/61/906e850d3f83444507ecdc1fb9e085222104b5
+/.git/objects/67/ddd10fe349dc2acf922eea2b4a3e4fa5ea9429
+/.git/objects/68/5ce9f76ca15d09cf6e1be3e02b1a75ed9ad67d
+/.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc
+/.git/objects/6b/44ad28de6abbea42fc01b18dce452103d9e7f6
+/.git/objects/6b/5cf7797e750cc6bfa17f8e214898cc20423a3f
+/.git/objects/6b/9b0a44c59f31c1431e5570954d90fdd726418d
+/.git/objects/6c/246424f93893cd073f3d1bd7f636fcdf2a8f6b
+/.git/objects/6c/f072a973f0e9b5df5708bc22f87d48cea5f3c0
+/.git/objects/6e/32fb5b36fb51d2d009519c061beb1b92f7b568
+/.git/objects/6e/43436847378f923cf6d07ac36edb0b7c6d94b6
+/.git/objects/6f/21b8c406d74ee4404188aab137e27a3ad825af
+/.git/objects/6f/f8fa664f641464a3c3a5680c2fc82cef12381f
+/.git/objects/71/411d71fbf4bcfaa03b646fa35c27d996f9d52e
+/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+/.git/objects/77/2704d8527483dc9bd3881838b5ae736e6a3080
+/.git/objects/7a/f0745ca3fa03f03d1553a4c3cdfb74644f9e67
+/.git/objects/7e/d0b31d9dbdcdd0e1f796f94a8a0edee9188f76
+/.git/objects/7f/1d432fbe858693e07e0f8841e84c792af2031d
+/.git/objects/7f/b0d4d339e78998d525baf7d47c1bb8a7ee05de
+/.git/objects/80/22bc8bdf4cb285c65c6e05758f2a53a2a19be6
+/.git/objects/80/2c90f38a670110c5b39e678067d43aa56af5f8
+/.git/objects/85/ce4526c7499f9d59944e1e006278d669c09343
+/.git/objects/87/616f238482a6137fa0e9ecf3b29a47e08ba574
+/.git/objects/88/ecd90b14e8bd5850f801f539c4edeec367a1ad
+/.git/objects/8d/2d97a18f77e17c906c6f06e314308254d3014d
+/.git/objects/8e/5fca5fd0d4a83341928232bebb03ddc063fa39
+/.git/objects/90/c179d86e49e8f9cb01f9f441c21477b64b8cd8
+/.git/objects/91/69f879d5c8964f429329cacbb228d900a0f368
+/.git/objects/93/a9ff49344da6ca9b0bc1754a35a8642b385561
+/.git/objects/96/3aff0b633cf34ac705e22de6d5f7052727ebd4
+/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+/.git/objects/97/b899881080136b7329ecccd6a8ff2462d5241b
+/.git/objects/9a/6474cc575269218262e5befaf996589b4b0725
+/.git/objects/a1/68398a440f4c5345b3b3565e9f86f87edab677
+/.git/objects/a4/2329826914d12946dca5006a756bd71d2e40a6
+/.git/objects/a5/c96ae3c6227dc41e4ec78126f6331112f18d28
+/.git/objects/a8/e2b1bf7684eb227f451507d3a2426bfe896c8f
+/.git/objects/a9/7e1ab2919f0342e08b4871f42597fc25cba4ac
+/.git/objects/a9/cfc582bac4e2f77cb3a782cce2276797e3cf6d
+/.git/objects/aa/89a00b93e7cebdbd94d5acb4d83d98a3d23ae4
+/.git/objects/ac/0a3f4ff245717751593bf94456a23062670281
+/.git/objects/ac/14d6758736a7039859e268380d59a3b326b399
+/.git/objects/b2/3b264149f35fafc61fc64e209a58ec653e8560
+/.git/objects/b9/b281651bbdd7a26d9a588cfec35c0470aa921b
+/.git/objects/be/bbdf2844f2f1e3a5f33e187b312baa769c280a
+/.git/objects/bf/b3e39173d53801417602636de619113423353a
+/.git/objects/c0/6c06bae75f4eadb6f3b484daaf0df95379fea0
+/.git/objects/c1/c4ebd69aa9312836630aa6b99ca0252ee2f0ae
+/.git/objects/c2/fdd0799e3b7cf389c83410273861f583ae8716
+/.git/objects/c3/e53b84164752b49157a170c31cc7533f5d2fee
+/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+/.git/objects/c9/37f78182ddde0206560e0e602788143fdb5b9d
+/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+/.git/objects/cd/5da4c8fba2eb39aace10ad59a84be6d094862d
+/.git/objects/d0/16713dfcdd945a90764e59637156e4e77b239a
+/.git/objects/d0/59b6e9c195a2a7ce448272efd11719d3715c61
+/.git/objects/d0/a590a1e82da3c72a9484491b61e6bccaf4b6e3
+/.git/objects/d0/d5683a4b63386ff54b787640fcf8c1e9ce605b
+/.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78
+/.git/objects/d1/cbca8c4639e7e89c458a3c273f0acebd9ebe1a
+/.git/objects/d2/0302c9b0f578ec42967969e2892bc4416d66ca
+/.git/objects/d5/62bfa38c545099391ee84f30644aca5c4e04a3
+/.git/objects/d6/81f37c2ad71d1a24bfccf5c039cb90a8b74b6e
+/.git/objects/da/116ccca88cede3c380ac4f2910e7fbfec3c98c
+/.git/objects/de/8b77f039b60bc7ef5ca03a85e9712c734fb3c0
+/.git/objects/df/54c5a865dbf20b853a1e12c04a01c76b3a9285
+/.git/objects/df/ab375b6db323649427d9b468018424e7b318ad
+/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+/.git/objects/e7/0c3da4a581efea1f3c3cecbcadf932c80ee641
+/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+/.git/objects/ea/f2034dc4702cda5cdea9276aa329109efd76f1
+/.git/objects/eb/02039079a5e73413c80696c73153fca1810484
+/.git/objects/f1/3b51941ba05149023344e796411aa0c6a438cb
+/.git/objects/f1/7257c6cddd76fb6c04620a5cca5065726c7022
+/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+/.git/objects/f3/e544736920f9d8e349dae1185582ef78300898
+/.git/objects/f4/a9130b95f1231b86c72ef6d1ce3c3c8198905e
+/.git/objects/f5/4b8fcefc1c6a57a32eb9779db43168b0186fe0
+/.git/objects/f6/07a662cc46985756ea5b4f041dc23347f24769
+/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+/.git/objects/fc/ccbf936220654899cea62a94163562ca9ebcef
+/.git/objects/fc/cd7f38f6769c6fc941db1b04fa52f06088c55b
+/.git/HEAD
+/.git/index
+/.git/config
+/.git/ORIG_HEAD
+/.git/FETCH_HEAD
+/.git/description
+/.git/COMMIT_EDITMSG
+/.log/history.log
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_8_24_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__8_24_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__1_50_PM__Default_.xml
+/.idea/copyright/profiles_settings.xml
+/.idea/libraries/algs4.xml
+/.idea/libraries/stdlib.xml
+/.idea/.name
+/.idea/vcs.xml
+/.idea/misc.xml
+/.idea/modules.xml
+/.idea/compiler.xml
+/.idea/workspace.xml
+/.idea/uiDesigner.xml
+/tests/.donotlog
+/tests/png2emap.py
+/tests/ramp.png.emap
+/tests/ramp2.png.emap
+/tests/ramp3.png.emap
+/tests/mazeAB.png.emap
+/tests/usa128.png.emap
+/tests/usa256.png.emap
+/tests/usa1024.png.emap
+/tests/maze32_0.png.emap
+/tests/maze32_1.png.emap
+/tests/maze232_0.png.emap
+/tests/maze320_0.png.emap
+/tests/mazeBrain.png.emap
+/.cos265
+/readme.html
+/P04_Pathfinding.iml
+
+--[ 2022.11.04.11.53.15.793.0 ]--
+InitFile: /src/Walker.java
+import java.util.Iterator;
+
+/**
+ * Walker takes an Iterable of Coords and simulates an individual
+ * walking along the path over the given Terrain
+ */
+public class Walker {
+
+    // terrain: the Terrain the Walker traverses
+    // path: the sequence of Coords the Walker follows
+    public Walker(Terrain terrain, Iterable<Coord> path) {
+    }
+
+    // returns the Walker's current location
+    public Coord getLocation() {
+        return null;
+    }
+
+    // returns true if Walker has reached the end Coord (last in path)
+    public boolean doneWalking() {
+        return true;
+    }
+
+    // advances the Walker along path
+    // byTime: how long the Walker should traverse (may be any non-negative value)
+    public void advance(float byTime) {
+    }
+
+}
+
+--[ 2022.11.04.11.53.15.793.1 ]--
+InitFile: /src/Coord.java
+/**
+ * Coordinates is an immutable type that store the tuple (i, j)
+ */
+public final class Coord {
+    private final int i;
+    private final int j;
+
+    public Coord(int i, int j) {
+        this.i = i;
+        this.j = j;
+    }
+
+    public int getI() { return i; }
+    public int getJ() { return j; }
+
+    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
+        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
+    }
+    public boolean isInBounds(Coord min, Coord max) {
+        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
+    }
+
+    public Coord add(int addI, int addJ) {
+        return new Coord(i + addI, j + addJ);
+    }
+    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }
+
+    public String toString() { return "(" + i + "," + j + ")"; }
+
+    public boolean equals(Object o) {
+        if(this == o) return true;
+        if(o == null) return false;
+        if(o.getClass() != this.getClass()) return false;
+        Coord that = (Coord) o;
+        if(this.i != that.i) return false;
+        if(this.j != that.j) return false;
+        return true;
+    }
+}
+
+--[ 2022.11.04.11.53.15.794.0 ]--
+InitFile: /src/InteractivePathfinderVisualizer.java
+import java.awt.event.KeyEvent;
+//kate was here
+/**
+ * InteractivePathfinderVisualizer visualizes the terrain and the computed
+ * path and allows the user to change parameters of the Pathfinder.  Below
+ * is a list of commands and what they do.  Note: some of the commands
+ * modify the properties of the path finder and some modify the terrain.
+ *
+ * Command        Action                                      Terrain
+ * C              clear path
+ * space          recompute path
+ * S/E            set start/end location to mouse
+ * left/right     halve/double path search heuristic value
+ * 0/1            set path search heuristic to 0 or 1
+ * W              start a walker to show the path
+ * R              randomly generate a new terrain                *
+ * M              smooths terrain under mouse                    *
+ * shift+M        smooths all terrain                            *
+ * up/down        increase/decrease terrain under mouse          *
+ */
+
+public class InteractivePathfinderVisualizer {
+    private final static int DELAY = 10;
+
+    // sets how many redraws it should take for the walker to reach its destination
+    private final static float STEPS_TO_WALK = 100.0f;
+
+    // for convenience, here are the emap files that are located under heightmaps/ folder
+    // the python script in that folder converts png files to emap. \
+    // you can use it to create your own maps to test your code
+    private final static String[] emaps = {
+            "maze32_0.png.emap",    // 0   (32x32 maze)
+            "maze32_1.png.emap",    // 1   (another 32x32 maze)
+            "maze232_0.png.emap",   // 2   (232x232 maze)
+            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
+            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
+            "mazeBrain.png.emap",   // 5   (...)
+            "ramp.png.emap",        // 6   (some tests)
+            "ramp2.png.emap",       // 7   (...)
+            "ramp3.png.emap",       // 8   (...)
+            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
+            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
+            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
+    };
+
+    private final static String emapFilename = emaps[2];        // change index to load a different elevation map
+
+
+
+    public static void main(String[] args) {
+        Terrain terrain = new Terrain(emapFilename);
+        Pathfinder pf = new Pathfinder(terrain);
+        int N = terrain.getN();
+
+        StdDraw.show(0);
+
+        // set default starting and ending locations
+        pf.setPathStart(new Coord(1, 1));
+        pf.setPathEnd(new Coord(N-3, N-3));
+
+        // find a path
+        pf.resetPath();
+        pf.computePath();
+
+        PathfinderVisualizer.draw(terrain, pf, null, N);
+        StdDraw.show(DELAY);
+
+        // prevent repeated applications
+        boolean keyboardR = false;
+        boolean keyboardM = false;
+
+        Walker walker = null;
+
+        while(true) {
+            boolean recompute = false;
+            boolean redraw = false;
+
+            // mouse location on map
+            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
+            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
+            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
+                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
+                float m = keyboardLeft ? 0.5f : 2.0f;
+                float h = pf.getHeuristic() * m;
+                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
+                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
+                float h = keyboard0 ? 0 : 1;
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
+                pf.resetPath();
+                walker = null;
+                redraw = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
+                TerrainEditor.setFractalHeights(terrain);
+                TerrainEditor.clampHeights(terrain);
+                recompute = true;
+            }
+            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
+                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
+                    if(!keyboardM) {
+                        TerrainEditor.smoothHeights(terrain);
+                        recompute = true;
+                    }
+                } else {
+                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
+                    recompute = true;
+                }
+            }
+            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
+                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
+                float add = keyboardUp ? 8.0f : -8.0f;
+                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
+                pf.setPathStart(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
+                pf.setPathEnd(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
+                Iterable<Coord> path = pf.getPathSolution();
+                if(path != null) {
+                    walker = new Walker(terrain, pf.getPathSolution());
+                }
+            }
+
+            if(walker != null) {
+                if(walker.doneWalking()) {
+                    walker = null;
+                } else {
+                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
+                }
+                redraw = true;
+            }
+
+            if(recompute) {
+                walker = null;
+                pf.resetPath();
+                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
+                    pf.computePath();
+                }
+                redraw = true;
+            }
+
+            if(redraw) {
+                PathfinderVisualizer.draw(terrain, pf, walker, N);
+                StdDraw.show(DELAY);
+            } else {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    /* do nothing */
+                }
+            }
+        }
+    }
+}
+
+--[ 2022.11.04.11.53.15.794.1 ]--
+InitFile: /src/Terrain.java
+import java.lang.IndexOutOfBoundsException;
+
+/**
+ * Terrain stores elevations for map and computes distance and
+ * cost in traversing the terrain.
+ */
+
+public class Terrain {
+    private int N;
+    private int[][] heights;
+
+    public Terrain(int N) {
+        this.N = N;
+        this.heights = new int[N][N];
+    }
+
+    public Terrain(int[][] heights) {
+        this.N = heights.length;
+        this.heights = heights;
+    }
+
+    public Terrain(String emapfile) {
+        In in = new In(emapfile);
+        this.N = in.readInt();
+        this.heights = new int[N][N];
+        for (int j = 0; j < N; j++) {
+            for (int i = 0; i < N; i++) {
+                this.heights[i][j] = in.readInt();
+            }
+        }
+    }
+
+    public int getN() {
+        return N;
+    }
+
+    public void setHeight(int i, int j, int h) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        heights[i][j] = h;
+    }
+    public void setHeight(int i, int j, float h) {
+        setHeight(i, j, (int) h);
+    }
+    public void setHeight(Coord loc, int h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+    public void setHeight(Coord loc, float h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+
+    public int getHeight(int i, int j) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        return heights[i][j];
+    }
+    public int getHeight(Coord loc) {
+        return getHeight(loc.getI(), loc.getJ());
+    }
+
+    // computes distance between (i0,j0) and (i1,j1) as the crow flies
+    public float computeDistance(int i0, int j0, int i1, int j1) {
+        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+    }
+    public float computeDistance(Coord c0, Coord c1) {
+        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+
+    public float computeTravelCost(int i0, int j0, int i1, int j1) {
+        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
+        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
+        float dist = computeDistance(i0,j0, i1,j1);
+        return (1.0f + climb) * dist;
+    }
+    public float computeTravelCost(Coord c0, Coord c1) {
+        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+    public float computeTravelCost(Iterable<Coord> cs) {
+        Coord c0 = null;
+        float cost = 0.0f;
+        for(Coord c1 : cs) {
+            if(c0 != null) cost += computeTravelCost(c0, c1);
+            c0 = c1;
+        }
+        return cost;
+    }
+}
+
+--[ 2022.11.04.11.53.15.794.2 ]--
+InitFile: /.cos265
+
+
+--[ 2022.11.04.11.53.15.794.3 ]--
+InitFile: /src/TerrainEditor.java
+/**
+ * The following class provides some simple terrain editing functions.
+ */
+public class TerrainEditor {
+    private static float rndRadius(float d) {
+        return (float)StdRandom.uniform(-d,d);
+    }
+
+    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
+        int N = terrain.getN();
+        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
+        if(!isset[i + j * N]) {
+            isset[i + j * N] = true;
+            terrain.setHeight(i, j, dh);
+        }
+        return terrain.getHeight(i,j);
+    }
+
+    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
+        int id = i1-i0;
+        int jd = j1-j0;
+        int i01 = (i0+i1)/2;
+        int j01 = (j0+j1)/2;
+
+        if(id <= 1 && jd <= 1) return;
+
+        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
+        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
+        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
+        float h11 = getFractalHeight(i1,j1,32,terrain,isset);
+
+        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);
+
+        float d0001 = (h00 + h01) / 2 + rndRadius(d);
+        float d0010 = (h00 + h10) / 2 + rndRadius(d);
+        float d1101 = (h11 + h01) / 2 + rndRadius(d);
+        float d1110 = (h11 + h10) / 2 + rndRadius(d);
+
+        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
+        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
+        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
+        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);
+
+        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
+        float hm = getFractalHeight(i01, j01, dm, terrain,isset);
+
+        if(id > 1 && jd > 1) {
+            setFractalHeights(i0, j0, i01, j01, terrain, isset);
+            setFractalHeights(i01, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i01, j1, terrain, isset);
+            setFractalHeights(i01, j01, i1, j1, terrain, isset);
+        } else if(jd > 1) {
+            setFractalHeights(i0, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i1, j1, terrain, isset);
+        } else {
+            setFractalHeights(i0, j0, i01, j1, terrain, isset);
+            setFractalHeights(i01, j0, i1, j1, terrain, isset);
+        }
+    }
+
+    public static void setFractalHeights(Terrain terrain) {
+        int N = terrain.getN();
+        boolean[] isset = new boolean[N*N];
+        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
+    }
+
+    public static void smoothHeights(Terrain terrain) {
+        int N = terrain.getN();
+        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
+        smoothHeights(N/2, N/2, radius, false, terrain);
+    }
+
+    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
+        final int N = terrain.getN();
+        final int w = 2*radius+1;
+        float[] s = new float[w*w];
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+
+                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
+                if(m <= 0.0000001) {
+                    s[sidx] = terrain.getHeight(i,j);
+                    continue;
+                }
+                float h = 0;
+                int c = 0;
+                if(i > 0 && j > 0) {
+                    h += terrain.getHeight(i-1,j-1);
+                    c += 1;
+                }
+                if(i < N-1 && j > 0) {
+                    h += terrain.getHeight(i+1,j-1);
+                    c += 1;
+                }
+                if(i > 0 && j < N-1) {
+                    h += terrain.getHeight(i-1,j+1);
+                    c += 1;
+                }
+                if(i < N-1 && j < N-1) {
+                    h += terrain.getHeight(i+1,j+1);
+                    c += 1;
+                }
+                if(i > 0) {
+                    h += terrain.getHeight(i-1,j);
+                    c += 1;
+                }
+                if(j > 0) {
+                    h += terrain.getHeight(i,j-1);
+                    c += 1;
+                }
+                if(i < N-1) {
+                    h += terrain.getHeight(i+1,j);
+                    c += 1;
+                }
+                if(j < N-1) {
+                    h += terrain.getHeight(i,j+1);
+                    c += 1;
+                }
+                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
+            }
+        }
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+                terrain.setHeight(i, j, s[sidx]);
+            }
+        }
+    }
+
+    public static void clampHeights(Terrain terrain) {
+        int N = terrain.getN();
+        for(int i = 0; i < N; i++) {
+            for(int j = 0; j < N; j++) {
+                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
+            }
+        }
+    }
+
+    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
+        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
+        if(!fallOff) return 1;
+        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
+        if(d2 > radius*radius) return 0;
+        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
+    }
+
+    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
+        final int N = terrain.getN();
+        for(int ja = -radius; ja <= radius; ja++) {
+            int r = j + ja;
+            if(r < 0 || r >= N) continue;
+            for(int ia = -radius; ia <= radius; ia++) {
+                int c = i + ia;
+                if(c < 0 || c >= N) continue;
+                float v = add * computeEffect(c, r, i, j, radius, true, N);
+                float h = terrain.getHeight(c, r) + v;
+                h = Math.max(0, Math.min(255, h));
+                terrain.setHeight(c, r, h);
+            }
+        }
+    }
+}
+
+--[ 2022.11.04.11.53.15.794.4 ]--
+InitFile: /P04_Pathfinding.iml
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.log" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="algs4" level="project" />
+    <orderEntry type="library" name="stdlib" level="project" />
+  </component>
+</module>
+
+--[ 2022.11.04.11.53.15.795.0 ]--
+InitFile: /src/PathfinderVisualizer.java
+/**
+ * PathfinderVisualizer visualizes the terrain and found path.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+
+public class PathfinderVisualizer {
+
+    // delay in milliseconds (controls animation speed)
+    private final static int DELAY = 100;
+
+    // color for different elevations.  must be in ascending order!
+    private final static int[][] elevationColors = {
+            // h    r   g   b   where h=height, r=red, g=green, b=blue
+            {  0,   0,  0,  0},
+            {  2,   0,  0,160},
+            {  4,   0,224,224},
+            { 16, 192,192,  0},
+            { 64,  16,255, 16},
+            {128,  32,224, 32},
+            {192, 128,128,  8},
+            {224, 164,164,164},
+            {255, 255,255,255}
+    };
+
+    private final static Color cStart    = new Color(128, 128, 255);
+    private final static Color cEnd      = new Color(255, 128, 128);
+    private final static Color cSolution = new Color(255, 128, 255);
+    private final static Color cSearched = new Color(128,   0, 128);
+
+    // linearly interpolating between the corresponding rgb values
+    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * r0 + v1 * r1);
+        int g = (int)(v0 * g0 + v1 * g1);
+        int b = (int)(v0 * b0 + v1 * b1);
+        return new Color(r, g, b);
+    }
+    private static Color colorLERP(float v1, Color c0, Color c1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
+        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
+        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
+        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
+        return new Color(r, g, b, a);
+    }
+
+    // returns color for given height
+    private static Color height2Color(int h) {
+        h = Math.max(0, Math.min(255, h));
+
+        int[] ec0 = elevationColors[0];  // default lower bound
+        int[] ec1 = elevationColors[1];  // default upper bound
+
+        // find upper bound while updating lower bound
+        for(int i = 1; i < elevationColors.length; i++) {
+            ec1 = elevationColors[i];
+            if(h >= ec0[0] && h <= ec1[0]) break;
+            ec0 = ec1;
+        }
+
+        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
+        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
+        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));
+
+        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
+    }
+
+    private static void drawCircle(int i, int j, int N, double rad) {
+        int c = (int)((i+0.5f) * 464.0f / N);
+        int r = (int)((j+0.5f) * 464.0f / N);
+        StdDraw.circle(c + 24, 464 - r + 36, rad);
+    }
+    public static void drawCircle(Coord loc, int N, double rad) {
+        drawCircle(loc.getI(), loc.getJ(), N, rad);
+    }
+
+    private static void drawPath(Iterable<Coord> path, int N) {
+        boolean first = true;
+        int c0 = 0, r0 = 0;
+        for (Coord loc : path) {
+            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
+            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
+            if(!first) {
+                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
+            }
+            first = false;
+            c0 = c1; r0 = r1;
+        }
+    }
+
+    // draw N-by-N pathfinding map
+    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
+        StdDraw.clear();
+        StdDraw.setXscale(0, 512);
+        StdDraw.setYscale(0, 512);
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.filledSquare(256, 256 + 12, 464 / 2);
+
+        // draw terrain
+        for(int row = 0; row < 464; row++) {
+            int j = (int)((float)row/464.0f * N);
+            for(int col = 0; col < 464; col++) {
+                int i = (int)((float)col/464.0f * N);
+                Coord loc = new Coord(i,j);
+                Color c = height2Color(terrain.getHeight(loc));
+                if(pf.wasSearched(loc)) {
+                    c = colorLERP(0.50f, c, cSearched);
+                }
+                StdDraw.setPenColor(c);
+                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
+            }
+        }
+
+        // draw path start
+        if(pf.getPathStart() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathStart(), N, 4.0);
+
+            StdDraw.setPenColor(cStart);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathStart(), N, 4.0);
+        }
+
+        // draw path end
+        if(pf.getPathEnd() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+
+            StdDraw.setPenColor(cEnd);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+        }
+
+        // draw found path
+        if(pf.foundPath()) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawPath(pf.getPathSolution(), N);
+
+            StdDraw.setPenColor(cSolution);
+            StdDraw.setPenRadius(0.002);
+            drawPath(pf.getPathSolution(), N);
+        }
+
+        // draw walker
+        if(walker != null) {
+            Coord loc = walker.getLocation();
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+
+            StdDraw.setPenColor(StdDraw.WHITE);
+            StdDraw.setPenRadius(0.002);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+        }
+
+        // write status text
+        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
+        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
+        else               StdDraw.text(256, 12, "no path found");
+        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
+    }
+}
+
+--[ 2022.11.04.11.53.15.795.1 ]--
+InitFile: /src/Pathfinder.java
+import java.lang.IndexOutOfBoundsException;
+import java.lang.IllegalArgumentException;
+
+/**
+ * Pathfinder uses A* search to find a near optimal path
+ * between to locations with given terrain.
+ */
+//hiiiiiiiiiiii
+    //this is Makayla...
+public class Pathfinder {
+
+    /**
+     * PFNode will be the key for MinPQ (used in computePath())
+     */
+    private class PFNode implements Comparable<PFNode> {
+        // loc: the location of the PFNode
+        // fromNode: how did we get here? (linked list back to start)
+        Coord location;
+        PFNode previous;
+        float cost;
+        public PFNode(Coord loc, PFNode fromNode, float newCost) {
+           location=loc;
+           previous=fromNode;
+           cost=newCost;
+        }
+
+        // compares this with that, used to find minimum cost PFNode
+        public int compareTo(PFNode that) {
+            return this.compareTo(that);
+        }
+
+        // returns the cost to travel from starting point to this
+        // via the fromNode chain
+        public float getCost(float heuristic) {
+
+            return 0;
+        }
+
+        // returns if this PFNode is still valid
+        public boolean isValid() {
+            return false;
+        }
+
+        // invalidates the PFNode
+        public void invalidate() {
+        }
+
+        // returns if the PFNode has been used
+        public boolean isUsed() {
+            return true;
+        }
+
+        // uses the PFNode
+        public void use() { }
+
+        // returns an Iterable of PFNodes that surround this
+        public Iterable<PFNode> neighbors() {
+            Stack<PFNode> s = new Stack<>();
+            s.push(new PFNode(null, null, 0));
+            return s;
+        }
+    }
+
+    public Pathfinder(Terrain terrain) {
+    }
+    Coord pathStart=null;
+    Coord pathEnd=null;
+    float heuristic = 1;
+    boolean pathFound=false;
+    public void setPathStart(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathStart=loc;
+    }
+
+    public Coord getPathStart() { // this function is a little redundant if we
+                                  // just have a global var for it anyway...
+        return pathStart;
+    }
+
+    public void setPathEnd(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathEnd=loc;
+    }
+
+    public Coord getPathEnd() {
+        return pathEnd;
+    }
+
+    public void setHeuristic(float v) {
+        heuristic=v;
+    }
+
+    public float getHeuristic() {
+        return heuristic;
+    }
+
+    //cleans out the queues ??
+    public void resetPath() {
+    }
+
+    public void computePath() {
+        // make the priorety queue
+        Terrain map = new Terrain("maze232_0.png.emap");
+        MinPQ<PFNode> PQ = new MinPQ<>();
+        PFNode start = new PFNode(pathStart, null, 0);
+        PQ.insert(start);
+        while (!pathFound) {
+            PFNode location = PQ.delMin();
+
+            if (location.location == pathEnd) {    //if the location is the end
+                pathFound = true;
+                return;
+            }
+
+            if (location == null) return;
+
+            Coord[] neighbourList = checkNeighbour(location.location);  //give all the neighbours
+            float previousCost = location.cost;
+            for (int i = 0; i < 4; i++) {
+                float cost = map.computeTravelCost(location.location, neighbourList[i]);
+                PFNode temp = new PFNode(neighbourList[i], location, cost);
+                PQ.insert(temp);
+            }
+        }
+    }
+
+    private Coord[] checkNeighbour(Coord loc){
+        int x = loc.getI();   //row
+        int y = loc.getJ();   //col
+
+        Coord[] neighbourList = new Coord[4];
+        neighbourList[0] = loc.add(0, 1);   //up
+        neighbourList[1] = loc.add(-1, 0);  //left
+        neighbourList[2] = loc.add(0, -1);  //down
+        neighbourList[3] = loc.add(1, 0);   //right
+
+        //edge cases
+
+        return neighbourList;
+
+    }
+
+    public boolean foundPath() {
+        return pathFound;
+    }
+
+    public float getPathCost() {
+        return 0;
+    }
+
+    public int getSearchSize() {
+        return 0;
+    }
+
+    public Iterable<Coord> getPathSolution() {
+        return null;
+    }
+
+    public boolean wasSearched(Coord loc) {
+        return false;
+    }
+}
+
+--[ 2022.11.04.11.53.59.908.0 ]--
+DisposeComponent
+--[ 2022.11.05.15.36.52.812.0 ]--
+NewLogger: P04_Pathfinding
+Version: 1.5
+--[ 2022.11.05.15.36.53.015.0 ]--
+InitTree:
+/out/production/P04_Pathfinding/.donotlog
+/out/production/P04_Pathfinding/algs4.jar
+/out/production/P04_Pathfinding/stdlib.jar
+/out/production/P04_Pathfinding/Coord.class
+/out/production/P04_Pathfinding/png2emap.py
+/out/production/P04_Pathfinding/Walker.class
+/out/production/P04_Pathfinding/ramp.png.emap
+/out/production/P04_Pathfinding/Terrain.class
+/out/production/P04_Pathfinding/ramp2.png.emap
+/out/production/P04_Pathfinding/ramp3.png.emap
+/out/production/P04_Pathfinding/mazeAB.png.emap
+/out/production/P04_Pathfinding/usa128.png.emap
+/out/production/P04_Pathfinding/usa256.png.emap
+/out/production/P04_Pathfinding/Pathfinder.class
+/out/production/P04_Pathfinding/usa1024.png.emap
+/out/production/P04_Pathfinding/maze32_0.png.emap
+/out/production/P04_Pathfinding/maze32_1.png.emap
+/out/production/P04_Pathfinding/maze232_0.png.emap
+/out/production/P04_Pathfinding/maze320_0.png.emap
+/out/production/P04_Pathfinding/mazeBrain.png.emap
+/out/production/P04_Pathfinding/TerrainEditor.class
+/out/production/P04_Pathfinding/Pathfinder$PFNode.class
+/out/production/P04_Pathfinding/PathfinderVisualizer.class
+/out/production/P04_Pathfinding/InteractivePathfinderVisualizer.class
+/src/algs4.jar
+/src/Coord.java
+/src/stdlib.jar
+/src/Walker.java
+/src/Terrain.java
+/src/Pathfinder.java
+/src/TerrainEditor.java
+/src/PathfinderVisualizer.java
+/src/InteractivePathfinderVisualizer.java
+/.git/info/exclude
+/.git/logs/refs/heads/main
+/.git/logs/refs/remotes/origin/main
+/.git/logs/HEAD
+/.git/refs/heads/main
+/.git/refs/remotes/origin/main
+/.git/hooks/update.sample
+/.git/hooks/pre-push.sample
+/.git/hooks/commit-msg.sample
+/.git/hooks/pre-commit.sample
+/.git/hooks/pre-rebase.sample
+/.git/hooks/post-update.sample
+/.git/hooks/pre-receive.sample
+/.git/hooks/applypatch-msg.sample
+/.git/hooks/pre-applypatch.sample
+/.git/hooks/pre-merge-commit.sample
+/.git/hooks/push-to-checkout.sample
+/.git/hooks/fsmonitor-watchman.sample
+/.git/hooks/prepare-commit-msg.sample
+/.git/objects/00/83268a14a16b4a5dd867518f78733391a45c17
+/.git/objects/01/93c2673203020e3726e397a6870107f9e38aa9
+/.git/objects/02/b01225b71d3414a2e2cc73cafd334173831774
+/.git/objects/08/03327110344bdd9225216d43717854bdcb5a02
+/.git/objects/0a/0cc74c3c69529bc0b35efec4b33b4122f3f9d2
+/.git/objects/0a/223ed78fd4ba9e3c29d48824487e673a123de6
+/.git/objects/11/96e8a2e363c7dabd777bfe6bc8bd9c4f24983d
+/.git/objects/11/f974299e37fea0743352c5bb44bd670176a9c4
+/.git/objects/12/b0c09257d01178df8b7f1060740432172d7b42
+/.git/objects/13/ac099b7d719505f83e4bcc7f8d3e3324233f0e
+/.git/objects/14/1a3f4b2369df3af5a953caed0c4cab5f978deb
+/.git/objects/14/98d3ed54fd6d24a517dbb6edfdb89592a3a42f
+/.git/objects/17/9f9a625eb41082f81a6ba399335a590c13065d
+/.git/objects/19/758b3cfb8d02709de9b698387494c8b840197a
+/.git/objects/19/8f86a451262bb58f20fec4b4372511d319cb1e
+/.git/objects/1c/657c45ac423a783f740b198b8c2fb38ee7f1b9
+/.git/objects/1d/9870f3870280622cc38ff3a0db5d362720a2c9
+/.git/objects/1d/ba1a0866ebec020b4fff86ea9bec07c9be5f9c
+/.git/objects/1e/1b111e44a3392c3dc2f8c9e8466a2caa4c87f1
+/.git/objects/21/86213986a340219401746588209691c3a095a9
+/.git/objects/22/d1da271c9ad5057fed4e6702f0c556345d4b1e
+/.git/objects/28/3bac315169d5f131ab61d9a482b571b798e7e1
+/.git/objects/29/3bba6c1d610b4ce86b15d1a807bfd9512e1e31
+/.git/objects/2e/c358f7bcf4f758b64b2f2d516d8aadd28268c4
+/.git/objects/2f/8959443fe58250b1251ba5223cef6fae049f6a
+/.git/objects/2f/9b1b9136e49f3aa4604e0907ea0497bd459bc9
+/.git/objects/30/27eb765074649989e38ee5953c045f541f2514
+/.git/objects/31/0e1d1baa102c6827797e192b38e3f6d8629fc6
+/.git/objects/31/fd9bbe5bb6e815ef3de6539321474dc6aec3b3
+/.git/objects/33/ebf301bb19589b3acf4d18d1fc9bd8f90302f4
+/.git/objects/34/c40469b8879baee4fbd8d7ee3c930ed59cb6f3
+/.git/objects/35/21629ecf5199e7d9a5a177d2937d17e36b73d3
+/.git/objects/36/bd4febfa8552f3cead1307339c48c6a2c9afb9
+/.git/objects/38/57c26673f53453f16ced8fe4cb6e8efd294f3a
+/.git/objects/39/122c7c3262ceff1338c9cc29fd32418783debf
+/.git/objects/3d/dd471797ab3fd4fdaa9102e86d087b9c85ae6c
+/.git/objects/3e/7c188a1be72d5f1cce5cdf5779924b039be66a
+/.git/objects/43/e81b1e944a8a3a9f9e42f72a0c1140f9633327
+/.git/objects/44/3d1398732fb006321a93e89dc6ccbcc76cefb6
+/.git/objects/46/58c672f584d326af787728f4e52bb379ffbf98
+/.git/objects/47/bfeee24fec7f21d5ff12c1c28cc444d9ddba85
+/.git/objects/49/1df43ab4b5595701f6f144d36d667d96a0a282
+/.git/objects/49/d6a74a87046e6d92d7453d56a4da013dee44ff
+/.git/objects/4a/25ed2698823ce5825bc66c5a5c767c54af7731
+/.git/objects/4d/137de7a049bcd5094c3a60d8357d28d0b68990
+/.git/objects/4f/ce1d86b49521afe1cee4ed1c13b6396ebbc6f3
+/.git/objects/54/d71d3d486b9af299988fade384c5fb18962bc9
+/.git/objects/55/e133c8e1aa563ba7414e9ae3501bf8306293b2
+/.git/objects/56/c7b9737bf41d32b2b80dfaaba4b83b3237caae
+/.git/objects/59/631287f07bbd6e06894075d7a1b44ef1bd90d2
+/.git/objects/5d/7b147a2b1a70bc90f896e209482051cac3b3e0
+/.git/objects/5f/d0d49fc87a408e940f89257a84e42fd26db3f2
+/.git/objects/61/906e850d3f83444507ecdc1fb9e085222104b5
+/.git/objects/67/ddd10fe349dc2acf922eea2b4a3e4fa5ea9429
+/.git/objects/68/5ce9f76ca15d09cf6e1be3e02b1a75ed9ad67d
+/.git/objects/68/bcf84de8d9b44303a410eaa15011500fbc87dc
+/.git/objects/6b/44ad28de6abbea42fc01b18dce452103d9e7f6
+/.git/objects/6b/5cf7797e750cc6bfa17f8e214898cc20423a3f
+/.git/objects/6b/9b0a44c59f31c1431e5570954d90fdd726418d
+/.git/objects/6c/246424f93893cd073f3d1bd7f636fcdf2a8f6b
+/.git/objects/6c/f072a973f0e9b5df5708bc22f87d48cea5f3c0
+/.git/objects/6e/32fb5b36fb51d2d009519c061beb1b92f7b568
+/.git/objects/6e/43436847378f923cf6d07ac36edb0b7c6d94b6
+/.git/objects/6f/21b8c406d74ee4404188aab137e27a3ad825af
+/.git/objects/6f/f8fa664f641464a3c3a5680c2fc82cef12381f
+/.git/objects/71/411d71fbf4bcfaa03b646fa35c27d996f9d52e
+/.git/objects/74/a6a5d585c5ea37685f0464c4d008732ed403d9
+/.git/objects/77/2704d8527483dc9bd3881838b5ae736e6a3080
+/.git/objects/7a/f0745ca3fa03f03d1553a4c3cdfb74644f9e67
+/.git/objects/7e/d0b31d9dbdcdd0e1f796f94a8a0edee9188f76
+/.git/objects/7f/1d432fbe858693e07e0f8841e84c792af2031d
+/.git/objects/7f/b0d4d339e78998d525baf7d47c1bb8a7ee05de
+/.git/objects/80/22bc8bdf4cb285c65c6e05758f2a53a2a19be6
+/.git/objects/80/2c90f38a670110c5b39e678067d43aa56af5f8
+/.git/objects/85/ce4526c7499f9d59944e1e006278d669c09343
+/.git/objects/87/616f238482a6137fa0e9ecf3b29a47e08ba574
+/.git/objects/88/ecd90b14e8bd5850f801f539c4edeec367a1ad
+/.git/objects/8d/2d97a18f77e17c906c6f06e314308254d3014d
+/.git/objects/8e/5fca5fd0d4a83341928232bebb03ddc063fa39
+/.git/objects/90/c179d86e49e8f9cb01f9f441c21477b64b8cd8
+/.git/objects/91/69f879d5c8964f429329cacbb228d900a0f368
+/.git/objects/93/a9ff49344da6ca9b0bc1754a35a8642b385561
+/.git/objects/96/3aff0b633cf34ac705e22de6d5f7052727ebd4
+/.git/objects/96/cc43efa6a0885098044e976cd780bb42c68a70
+/.git/objects/97/b899881080136b7329ecccd6a8ff2462d5241b
+/.git/objects/9a/6474cc575269218262e5befaf996589b4b0725
+/.git/objects/a1/68398a440f4c5345b3b3565e9f86f87edab677
+/.git/objects/a4/2329826914d12946dca5006a756bd71d2e40a6
+/.git/objects/a5/c96ae3c6227dc41e4ec78126f6331112f18d28
+/.git/objects/a8/e2b1bf7684eb227f451507d3a2426bfe896c8f
+/.git/objects/a9/7e1ab2919f0342e08b4871f42597fc25cba4ac
+/.git/objects/a9/cfc582bac4e2f77cb3a782cce2276797e3cf6d
+/.git/objects/aa/89a00b93e7cebdbd94d5acb4d83d98a3d23ae4
+/.git/objects/ac/0a3f4ff245717751593bf94456a23062670281
+/.git/objects/ac/14d6758736a7039859e268380d59a3b326b399
+/.git/objects/b2/3b264149f35fafc61fc64e209a58ec653e8560
+/.git/objects/b9/b281651bbdd7a26d9a588cfec35c0470aa921b
+/.git/objects/be/bbdf2844f2f1e3a5f33e187b312baa769c280a
+/.git/objects/bf/b3e39173d53801417602636de619113423353a
+/.git/objects/c0/6c06bae75f4eadb6f3b484daaf0df95379fea0
+/.git/objects/c1/c4ebd69aa9312836630aa6b99ca0252ee2f0ae
+/.git/objects/c2/fdd0799e3b7cf389c83410273861f583ae8716
+/.git/objects/c3/e53b84164752b49157a170c31cc7533f5d2fee
+/.git/objects/c3/fde00d07458f153bdb5082ceb011de8dcc9721
+/.git/objects/c9/37f78182ddde0206560e0e602788143fdb5b9d
+/.git/objects/ca/9a474fc415e206e1d701688a299fa1b8bbd628
+/.git/objects/cd/5da4c8fba2eb39aace10ad59a84be6d094862d
+/.git/objects/d0/16713dfcdd945a90764e59637156e4e77b239a
+/.git/objects/d0/59b6e9c195a2a7ce448272efd11719d3715c61
+/.git/objects/d0/a590a1e82da3c72a9484491b61e6bccaf4b6e3
+/.git/objects/d0/d5683a4b63386ff54b787640fcf8c1e9ce605b
+/.git/objects/d1/bab8cd923b7e91662049128ad2665d98da3e78
+/.git/objects/d1/cbca8c4639e7e89c458a3c273f0acebd9ebe1a
+/.git/objects/d2/0302c9b0f578ec42967969e2892bc4416d66ca
+/.git/objects/d5/62bfa38c545099391ee84f30644aca5c4e04a3
+/.git/objects/d6/81f37c2ad71d1a24bfccf5c039cb90a8b74b6e
+/.git/objects/da/116ccca88cede3c380ac4f2910e7fbfec3c98c
+/.git/objects/de/8b77f039b60bc7ef5ca03a85e9712c734fb3c0
+/.git/objects/df/54c5a865dbf20b853a1e12c04a01c76b3a9285
+/.git/objects/df/ab375b6db323649427d9b468018424e7b318ad
+/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
+/.git/objects/e7/0c3da4a581efea1f3c3cecbcadf932c80ee641
+/.git/objects/e7/bedf3377d40335424fd605124d4761390218bb
+/.git/objects/e9/6534fb27b68192f27f985d3879e173ec77adb8
+/.git/objects/ea/f2034dc4702cda5cdea9276aa329109efd76f1
+/.git/objects/eb/02039079a5e73413c80696c73153fca1810484
+/.git/objects/f1/3b51941ba05149023344e796411aa0c6a438cb
+/.git/objects/f1/7257c6cddd76fb6c04620a5cca5065726c7022
+/.git/objects/f1/9e236587050cfbf8e8761a3460ac0c95e5fb0c
+/.git/objects/f3/e544736920f9d8e349dae1185582ef78300898
+/.git/objects/f4/a9130b95f1231b86c72ef6d1ce3c3c8198905e
+/.git/objects/f5/4b8fcefc1c6a57a32eb9779db43168b0186fe0
+/.git/objects/f6/07a662cc46985756ea5b4f041dc23347f24769
+/.git/objects/fb/e4187a868130477a51ea5c1bc60e0dce69cec4
+/.git/objects/fc/ccbf936220654899cea62a94163562ca9ebcef
+/.git/objects/fc/cd7f38f6769c6fc941db1b04fa52f06088c55b
+/.git/HEAD
+/.git/index
+/.git/config
+/.git/ORIG_HEAD
+/.git/FETCH_HEAD
+/.git/description
+/.git/COMMIT_EDITMSG
+/.log/history.log
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_8_24_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__8_24_PM__Default_.xml
+/.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22__1_50_PM__Default_.xml
+/.idea/copyright/profiles_settings.xml
+/.idea/libraries/algs4.xml
+/.idea/libraries/stdlib.xml
+/.idea/.name
+/.idea/vcs.xml
+/.idea/misc.xml
+/.idea/modules.xml
+/.idea/compiler.xml
+/.idea/workspace.xml
+/.idea/uiDesigner.xml
+/tests/.donotlog
+/tests/png2emap.py
+/tests/ramp.png.emap
+/tests/ramp2.png.emap
+/tests/ramp3.png.emap
+/tests/mazeAB.png.emap
+/tests/usa128.png.emap
+/tests/usa256.png.emap
+/tests/usa1024.png.emap
+/tests/maze32_0.png.emap
+/tests/maze32_1.png.emap
+/tests/maze232_0.png.emap
+/tests/maze320_0.png.emap
+/tests/mazeBrain.png.emap
+/.cos265
+/readme.html
+/P04_Pathfinding.iml
+
+--[ 2022.11.05.15.36.53.017.0 ]--
+InitFile: /src/Walker.java
+import java.util.Iterator;
+
+/**
+ * Walker takes an Iterable of Coords and simulates an individual
+ * walking along the path over the given Terrain
+ */
+public class Walker {
+
+    // terrain: the Terrain the Walker traverses
+    // path: the sequence of Coords the Walker follows
+    public Walker(Terrain terrain, Iterable<Coord> path) {
+    }
+
+    // returns the Walker's current location
+    public Coord getLocation() {
+        return null;
+    }
+
+    // returns true if Walker has reached the end Coord (last in path)
+    public boolean doneWalking() {
+        return true;
+    }
+
+    // advances the Walker along path
+    // byTime: how long the Walker should traverse (may be any non-negative value)
+    public void advance(float byTime) {
+    }
+
+}
+
+--[ 2022.11.05.15.36.53.017.1 ]--
+InitFile: /src/Coord.java
+/**
+ * Coordinates is an immutable type that store the tuple (i, j)
+ */
+public final class Coord {
+    private final int i;
+    private final int j;
+
+    public Coord(int i, int j) {
+        this.i = i;
+        this.j = j;
+    }
+
+    public int getI() { return i; }
+    public int getJ() { return j; }
+
+    public boolean isInBounds(int minI, int minJ, int maxI, int maxJ) {
+        return i >= minI && j >= minJ && i <= maxI && j <= maxJ;
+    }
+    public boolean isInBounds(Coord min, Coord max) {
+        return i >= min.i && i <= max.i && j >= min.j && j <= max.j;
+    }
+
+    public Coord add(int addI, int addJ) {
+        return new Coord(i + addI, j + addJ);
+    }
+    public Coord add(Coord that) { return new Coord(i + that.i, j + that.j); }
+
+    public String toString() { return "(" + i + "," + j + ")"; }
+
+    public boolean equals(Object o) {
+        if(this == o) return true;
+        if(o == null) return false;
+        if(o.getClass() != this.getClass()) return false;
+        Coord that = (Coord) o;
+        if(this.i != that.i) return false;
+        if(this.j != that.j) return false;
+        return true;
+    }
+}
+
+--[ 2022.11.05.15.36.53.018.0 ]--
+InitFile: /src/InteractivePathfinderVisualizer.java
+import java.awt.event.KeyEvent;
+//kate was here
+/**
+ * InteractivePathfinderVisualizer visualizes the terrain and the computed
+ * path and allows the user to change parameters of the Pathfinder.  Below
+ * is a list of commands and what they do.  Note: some of the commands
+ * modify the properties of the path finder and some modify the terrain.
+ *
+ * Command        Action                                      Terrain
+ * C              clear path
+ * space          recompute path
+ * S/E            set start/end location to mouse
+ * left/right     halve/double path search heuristic value
+ * 0/1            set path search heuristic to 0 or 1
+ * W              start a walker to show the path
+ * R              randomly generate a new terrain                *
+ * M              smooths terrain under mouse                    *
+ * shift+M        smooths all terrain                            *
+ * up/down        increase/decrease terrain under mouse          *
+ */
+
+public class InteractivePathfinderVisualizer {
+    private final static int DELAY = 10;
+
+    // sets how many redraws it should take for the walker to reach its destination
+    private final static float STEPS_TO_WALK = 100.0f;
+
+    // for convenience, here are the emap files that are located under heightmaps/ folder
+    // the python script in that folder converts png files to emap. \
+    // you can use it to create your own maps to test your code
+    private final static String[] emaps = {
+            "maze32_0.png.emap",    // 0   (32x32 maze)
+            "maze32_1.png.emap",    // 1   (another 32x32 maze)
+            "maze232_0.png.emap",   // 2   (232x232 maze)
+            "maze320_0.png.emap",   // 3   (same as maze32_0, only scaled up by 10x)
+            "mazeAB.png.emap",      // 4   (a maze from a site no longer online :( )
+            "mazeBrain.png.emap",   // 5   (...)
+            "ramp.png.emap",        // 6   (some tests)
+            "ramp2.png.emap",       // 7   (...)
+            "ramp3.png.emap",       // 8   (...)
+            "usa128.png.emap",      // 9   (elevation map of USA from https://bananas.openttd.org/en/heightmap/)
+            "usa256.png.emap",      // 10  (same as usa128, only higher resolution)
+            "usa1024.png.emap",     // 11  (same as usa128, only higher resolution
+    };
+
+    private final static String emapFilename = emaps[2];        // change index to load a different elevation map
+
+
+
+    public static void main(String[] args) {
+        Terrain terrain = new Terrain(emapFilename);
+        Pathfinder pf = new Pathfinder(terrain);
+        int N = terrain.getN();
+
+        StdDraw.show(0);
+
+        // set default starting and ending locations
+        pf.setPathStart(new Coord(1, 1));
+        pf.setPathEnd(new Coord(N-3, N-3));
+
+        // find a path
+        pf.resetPath();
+        pf.computePath();
+
+        PathfinderVisualizer.draw(terrain, pf, null, N);
+        StdDraw.show(DELAY);
+
+        // prevent repeated applications
+        boolean keyboardR = false;
+        boolean keyboardM = false;
+
+        Walker walker = null;
+
+        while(true) {
+            boolean recompute = false;
+            boolean redraw = false;
+
+            // mouse location on map
+            int mouseI = (int) ((StdDraw.mouseX()-24) / 464 * N);
+            int mouseJ = (int) ((464 - (StdDraw.mouseY()-36)) / 464 * N);
+            boolean isMouseOnMap = (mouseI >=0 && mouseI < N && mouseJ >= 0 && mouseJ < N);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_LEFT) || StdDraw.isKeyPressed(KeyEvent.VK_RIGHT)) {
+                boolean keyboardLeft = StdDraw.isKeyPressed(KeyEvent.VK_LEFT);
+                float m = keyboardLeft ? 0.5f : 2.0f;
+                float h = pf.getHeuristic() * m;
+                h = Math.max(1.0f/1024.0f, Math.min(1048576.0f, h));
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_0) || StdDraw.isKeyPressed(KeyEvent.VK_1)) {
+                boolean keyboard0 = StdDraw.isKeyPressed(KeyEvent.VK_0);
+                float h = keyboard0 ? 0 : 1;
+                pf.setHeuristic(h);
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_C)) {
+                pf.resetPath();
+                walker = null;
+                redraw = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_R) && !keyboardR) {
+                TerrainEditor.setFractalHeights(terrain);
+                TerrainEditor.clampHeights(terrain);
+                recompute = true;
+            }
+            keyboardR = StdDraw.isKeyPressed(KeyEvent.VK_R);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_M)) {
+                if(StdDraw.isKeyPressed(KeyEvent.VK_SHIFT)) {
+                    if(!keyboardM) {
+                        TerrainEditor.smoothHeights(terrain);
+                        recompute = true;
+                    }
+                } else {
+                    TerrainEditor.smoothHeights(mouseI, mouseJ, N / 20, true, terrain);
+                    recompute = true;
+                }
+            }
+            keyboardM = StdDraw.isKeyPressed(KeyEvent.VK_M);
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_SPACE)) {
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_UP) || StdDraw.isKeyPressed(KeyEvent.VK_DOWN)) {
+                boolean keyboardUp = StdDraw.isKeyPressed(KeyEvent.VK_UP);
+                float add = keyboardUp ? 8.0f : -8.0f;
+                TerrainEditor.addHeight(mouseI, mouseJ, N / 20, add, terrain);
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_S)) {
+                pf.setPathStart(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(isMouseOnMap && StdDraw.isKeyPressed(KeyEvent.VK_E)) {
+                pf.setPathEnd(new Coord(mouseI, mouseJ));
+                recompute = true;
+            }
+
+            if(StdDraw.isKeyPressed(KeyEvent.VK_W)) {
+                Iterable<Coord> path = pf.getPathSolution();
+                if(path != null) {
+                    walker = new Walker(terrain, pf.getPathSolution());
+                }
+            }
+
+            if(walker != null) {
+                if(walker.doneWalking()) {
+                    walker = null;
+                } else {
+                    walker.advance(pf.getPathCost() / STEPS_TO_WALK);
+                }
+                redraw = true;
+            }
+
+            if(recompute) {
+                walker = null;
+                pf.resetPath();
+                if(pf.getPathStart() != null && pf.getPathEnd() != null) {
+                    pf.computePath();
+                }
+                redraw = true;
+            }
+
+            if(redraw) {
+                PathfinderVisualizer.draw(terrain, pf, walker, N);
+                StdDraw.show(DELAY);
+            } else {
+                try {
+                    Thread.sleep(10);
+                } catch (InterruptedException e) {
+                    /* do nothing */
+                }
+            }
+        }
+    }
+}
+
+--[ 2022.11.05.15.36.53.018.1 ]--
+InitFile: /src/Terrain.java
+import java.lang.IndexOutOfBoundsException;
+
+/**
+ * Terrain stores elevations for map and computes distance and
+ * cost in traversing the terrain.
+ */
+
+public class Terrain {
+    private int N;
+    private int[][] heights;
+
+    public Terrain(int N) {
+        this.N = N;
+        this.heights = new int[N][N];
+    }
+
+    public Terrain(int[][] heights) {
+        this.N = heights.length;
+        this.heights = heights;
+    }
+
+    public Terrain(String emapfile) {
+        In in = new In(emapfile);
+        this.N = in.readInt();
+        this.heights = new int[N][N];
+        for (int j = 0; j < N; j++) {
+            for (int i = 0; i < N; i++) {
+                this.heights[i][j] = in.readInt();
+            }
+        }
+    }
+
+    public int getN() {
+        return N;
+    }
+
+    public void setHeight(int i, int j, int h) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        heights[i][j] = h;
+    }
+    public void setHeight(int i, int j, float h) {
+        setHeight(i, j, (int) h);
+    }
+    public void setHeight(Coord loc, int h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+    public void setHeight(Coord loc, float h) {
+        setHeight(loc.getI(), loc.getJ(), h);
+    }
+
+    public int getHeight(int i, int j) {
+        if(i < 0 || j < 0 || i >= N || j >= N)
+            throw new IndexOutOfBoundsException("i and j must be in [0,N)");
+        return heights[i][j];
+    }
+    public int getHeight(Coord loc) {
+        return getHeight(loc.getI(), loc.getJ());
+    }
+
+    // computes distance between (i0,j0) and (i1,j1) as the crow flies
+    public float computeDistance(int i0, int j0, int i1, int j1) {
+        return (float)Math.sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+    }
+    public float computeDistance(Coord c0, Coord c1) {
+        return computeDistance(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+
+    public float computeTravelCost(int i0, int j0, int i1, int j1) {
+        float h0 = getHeight(i0, j0), h1 = getHeight(i1, j1);
+        float climb = (float)Math.pow(Math.abs(h0 - h1) * 1000.0, 1.5);
+        float dist = computeDistance(i0,j0, i1,j1);
+        return (1.0f + climb) * dist;
+    }
+    public float computeTravelCost(Coord c0, Coord c1) {
+        return computeTravelCost(c0.getI(), c0.getJ(), c1.getI(), c1.getJ());
+    }
+    public float computeTravelCost(Iterable<Coord> cs) {
+        Coord c0 = null;
+        float cost = 0.0f;
+        for(Coord c1 : cs) {
+            if(c0 != null) cost += computeTravelCost(c0, c1);
+            c0 = c1;
+        }
+        return cost;
+    }
+}
+
+--[ 2022.11.05.15.36.53.019.0 ]--
+InitFile: /.cos265
+
+
+--[ 2022.11.05.15.36.53.021.0 ]--
+InitFile: /src/TerrainEditor.java
+/**
+ * The following class provides some simple terrain editing functions.
+ */
+public class TerrainEditor {
+    private static float rndRadius(float d) {
+        return (float)StdRandom.uniform(-d,d);
+    }
+
+    private static float getFractalHeight(int i, int j, float dh, Terrain terrain, boolean[] isset) {
+        int N = terrain.getN();
+        dh = Math.max(-64, Math.min(255+64, dh));   // allow the height to go just a bit out of range
+        if(!isset[i + j * N]) {
+            isset[i + j * N] = true;
+            terrain.setHeight(i, j, dh);
+        }
+        return terrain.getHeight(i,j);
+    }
+
+    private static void setFractalHeights(int i0, int j0, int i1, int j1, Terrain terrain, boolean[] isset) {
+        int id = i1-i0;
+        int jd = j1-j0;
+        int i01 = (i0+i1)/2;
+        int j01 = (j0+j1)/2;
+
+        if(id <= 1 && jd <= 1) return;
+
+        float h00 = getFractalHeight(i0,j0,32,terrain,isset);
+        float h01 = getFractalHeight(i0,j1,32,terrain,isset);
+        float h10 = getFractalHeight(i1,j0,32,terrain,isset);
+        float h11 = getFractalHeight(i1,j1,32,terrain,isset);
+
+        float d = (float)(Math.sqrt((i1-i0)*(i1-i0) + (j1-j0)*(j1-j0)) * 0.5);
+
+        float d0001 = (h00 + h01) / 2 + rndRadius(d);
+        float d0010 = (h00 + h10) / 2 + rndRadius(d);
+        float d1101 = (h11 + h01) / 2 + rndRadius(d);
+        float d1110 = (h11 + h10) / 2 + rndRadius(d);
+
+        float h0001 = getFractalHeight(i0, j01, d0001, terrain,isset);
+        float h0010 = getFractalHeight(i01, j0, d0010, terrain,isset);
+        float h1101 = getFractalHeight(i01, j1, d1101, terrain,isset);
+        float h1110 = getFractalHeight(i1, j01, d1110, terrain,isset);
+
+        float dm = (float)((h0001 + h0010 + h1101 + h1110) / 4.0);
+        float hm = getFractalHeight(i01, j01, dm, terrain,isset);
+
+        if(id > 1 && jd > 1) {
+            setFractalHeights(i0, j0, i01, j01, terrain, isset);
+            setFractalHeights(i01, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i01, j1, terrain, isset);
+            setFractalHeights(i01, j01, i1, j1, terrain, isset);
+        } else if(jd > 1) {
+            setFractalHeights(i0, j0, i1, j01, terrain, isset);
+            setFractalHeights(i0, j01, i1, j1, terrain, isset);
+        } else {
+            setFractalHeights(i0, j0, i01, j1, terrain, isset);
+            setFractalHeights(i01, j0, i1, j1, terrain, isset);
+        }
+    }
+
+    public static void setFractalHeights(Terrain terrain) {
+        int N = terrain.getN();
+        boolean[] isset = new boolean[N*N];
+        setFractalHeights(0, 0, N - 1, N - 1, terrain, isset);
+    }
+
+    public static void smoothHeights(Terrain terrain) {
+        int N = terrain.getN();
+        int radius = (int)Math.ceil(Math.sqrt(N*N/2.0f));
+        smoothHeights(N/2, N/2, radius, false, terrain);
+    }
+
+    public static void smoothHeights(int ic, int jc, int radius, boolean fallOff, Terrain terrain) {
+        final int N = terrain.getN();
+        final int w = 2*radius+1;
+        float[] s = new float[w*w];
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+
+                float m = computeEffect(i, j, ic, jc, radius, fallOff, N);
+                if(m <= 0.0000001) {
+                    s[sidx] = terrain.getHeight(i,j);
+                    continue;
+                }
+                float h = 0;
+                int c = 0;
+                if(i > 0 && j > 0) {
+                    h += terrain.getHeight(i-1,j-1);
+                    c += 1;
+                }
+                if(i < N-1 && j > 0) {
+                    h += terrain.getHeight(i+1,j-1);
+                    c += 1;
+                }
+                if(i > 0 && j < N-1) {
+                    h += terrain.getHeight(i-1,j+1);
+                    c += 1;
+                }
+                if(i < N-1 && j < N-1) {
+                    h += terrain.getHeight(i+1,j+1);
+                    c += 1;
+                }
+                if(i > 0) {
+                    h += terrain.getHeight(i-1,j);
+                    c += 1;
+                }
+                if(j > 0) {
+                    h += terrain.getHeight(i,j-1);
+                    c += 1;
+                }
+                if(i < N-1) {
+                    h += terrain.getHeight(i+1,j);
+                    c += 1;
+                }
+                if(j < N-1) {
+                    h += terrain.getHeight(i,j+1);
+                    c += 1;
+                }
+                s[sidx] = (1-m) * terrain.getHeight(i,j) + m * h / c;
+            }
+        }
+        for(int ia = -radius; ia <= radius; ia++) {
+            int i = ic + ia;
+            if(i < 0 || i >= N) continue;
+            for(int ja = -radius; ja <= radius; ja++) {
+                int j = jc + ja;
+                if(j < 0 || j >= N) continue;
+                int sidx = (ia+radius) + (ja+radius)*w;
+                terrain.setHeight(i, j, s[sidx]);
+            }
+        }
+    }
+
+    public static void clampHeights(Terrain terrain) {
+        int N = terrain.getN();
+        for(int i = 0; i < N; i++) {
+            for(int j = 0; j < N; j++) {
+                terrain.setHeight(i, j, Math.max(0, Math.min(255, terrain.getHeight(i, j))));
+            }
+        }
+    }
+
+    private static float computeEffect(int i, int j, int ic, int jc, int radius, boolean fallOff, int N) {
+        if(i < 0 || j < 0 || i >= N || j >= N) return 0;
+        if(!fallOff) return 1;
+        int d2 = (ic-i)*(ic-i)+(jc-j)*(jc-j);
+        if(d2 > radius*radius) return 0;
+        return ((float)radius - (float)Math.sqrt(d2)) / (float)radius;
+    }
+
+    public static void addHeight(int i, int j, int radius, float add, Terrain terrain) {
+        final int N = terrain.getN();
+        for(int ja = -radius; ja <= radius; ja++) {
+            int r = j + ja;
+            if(r < 0 || r >= N) continue;
+            for(int ia = -radius; ia <= radius; ia++) {
+                int c = i + ia;
+                if(c < 0 || c >= N) continue;
+                float v = add * computeEffect(c, r, i, j, radius, true, N);
+                float h = terrain.getHeight(c, r) + v;
+                h = Math.max(0, Math.min(255, h));
+                terrain.setHeight(c, r, h);
+            }
+        }
+    }
+}
+
+--[ 2022.11.05.15.36.53.021.1 ]--
+InitFile: /P04_Pathfinding.iml
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.log" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="algs4" level="project" />
+    <orderEntry type="library" name="stdlib" level="project" />
+  </component>
+</module>
+
+--[ 2022.11.05.15.36.53.023.0 ]--
+InitFile: /src/PathfinderVisualizer.java
+/**
+ * PathfinderVisualizer visualizes the terrain and found path.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+
+public class PathfinderVisualizer {
+
+    // delay in milliseconds (controls animation speed)
+    private final static int DELAY = 100;
+
+    // color for different elevations.  must be in ascending order!
+    private final static int[][] elevationColors = {
+            // h    r   g   b   where h=height, r=red, g=green, b=blue
+            {  0,   0,  0,  0},
+            {  2,   0,  0,160},
+            {  4,   0,224,224},
+            { 16, 192,192,  0},
+            { 64,  16,255, 16},
+            {128,  32,224, 32},
+            {192, 128,128,  8},
+            {224, 164,164,164},
+            {255, 255,255,255}
+    };
+
+    private final static Color cStart    = new Color(128, 128, 255);
+    private final static Color cEnd      = new Color(255, 128, 128);
+    private final static Color cSolution = new Color(255, 128, 255);
+    private final static Color cSearched = new Color(128,   0, 128);
+
+    // linearly interpolating between the corresponding rgb values
+    private static Color colorLERP(float v1, int r0, int g0, int b0, int r1, int g1, int b1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * r0 + v1 * r1);
+        int g = (int)(v0 * g0 + v1 * g1);
+        int b = (int)(v0 * b0 + v1 * b1);
+        return new Color(r, g, b);
+    }
+    private static Color colorLERP(float v1, Color c0, Color c1) {
+        v1 = Math.max(0.0f, Math.min(1.0f, v1));
+        float v0 = 1.0f - v1;
+        int r = (int)(v0 * c0.getRed()   + v1 * c1.getRed());
+        int g = (int)(v0 * c0.getGreen() + v1 * c1.getGreen());
+        int b = (int)(v0 * c0.getBlue()  + v1 * c1.getBlue());
+        int a = (int)(v0 * c0.getAlpha() + v1 * c1.getAlpha());
+        return new Color(r, g, b, a);
+    }
+
+    // returns color for given height
+    private static Color height2Color(int h) {
+        h = Math.max(0, Math.min(255, h));
+
+        int[] ec0 = elevationColors[0];  // default lower bound
+        int[] ec1 = elevationColors[1];  // default upper bound
+
+        // find upper bound while updating lower bound
+        for(int i = 1; i < elevationColors.length; i++) {
+            ec1 = elevationColors[i];
+            if(h >= ec0[0] && h <= ec1[0]) break;
+            ec0 = ec1;
+        }
+
+        int h0=ec0[0], r0=ec0[1], g0=ec0[2], b0=ec0[3];
+        int h1=ec1[0], r1=ec1[1], g1=ec1[2], b1=ec1[3];
+        float v1 = ((float)(h - h0)) / ((float)(h1 - h0));
+
+        return colorLERP(v1, r0, g0, b0, r1, g1, b1);
+    }
+
+    private static void drawCircle(int i, int j, int N, double rad) {
+        int c = (int)((i+0.5f) * 464.0f / N);
+        int r = (int)((j+0.5f) * 464.0f / N);
+        StdDraw.circle(c + 24, 464 - r + 36, rad);
+    }
+    public static void drawCircle(Coord loc, int N, double rad) {
+        drawCircle(loc.getI(), loc.getJ(), N, rad);
+    }
+
+    private static void drawPath(Iterable<Coord> path, int N) {
+        boolean first = true;
+        int c0 = 0, r0 = 0;
+        for (Coord loc : path) {
+            int c1 = (int)((loc.getI()+0.5f) * 464.0f / N);
+            int r1 = (int)((loc.getJ()+0.5f) * 464.0f / N);
+            if(!first) {
+                StdDraw.line(c0 + 24, 464 - r0 + 36, c1 + 24, 464 - r1 + 36);
+            }
+            first = false;
+            c0 = c1; r0 = r1;
+        }
+    }
+
+    // draw N-by-N pathfinding map
+    public static void draw(Terrain terrain, Pathfinder pf, Walker walker, int N) {
+        StdDraw.clear();
+        StdDraw.setXscale(0, 512);
+        StdDraw.setYscale(0, 512);
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.filledSquare(256, 256 + 12, 464 / 2);
+
+        // draw terrain
+        for(int row = 0; row < 464; row++) {
+            int j = (int)((float)row/464.0f * N);
+            for(int col = 0; col < 464; col++) {
+                int i = (int)((float)col/464.0f * N);
+                Coord loc = new Coord(i,j);
+                Color c = height2Color(terrain.getHeight(loc));
+                if(pf.wasSearched(loc)) {
+                    c = colorLERP(0.50f, c, cSearched);
+                }
+                StdDraw.setPenColor(c);
+                StdDraw.filledSquare(col + 24, 464 - row + 36, 1);
+            }
+        }
+
+        // draw path start
+        if(pf.getPathStart() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathStart(), N, 4.0);
+
+            StdDraw.setPenColor(cStart);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathStart(), N, 4.0);
+        }
+
+        // draw path end
+        if(pf.getPathEnd() != null) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+
+            StdDraw.setPenColor(cEnd);
+            StdDraw.setPenRadius(0.002);
+            drawCircle(pf.getPathEnd(), N, 4.0);
+        }
+
+        // draw found path
+        if(pf.foundPath()) {
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            drawPath(pf.getPathSolution(), N);
+
+            StdDraw.setPenColor(cSolution);
+            StdDraw.setPenRadius(0.002);
+            drawPath(pf.getPathSolution(), N);
+        }
+
+        // draw walker
+        if(walker != null) {
+            Coord loc = walker.getLocation();
+            StdDraw.setPenColor(StdDraw.BLACK);
+            StdDraw.setPenRadius(0.006);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+
+            StdDraw.setPenColor(StdDraw.WHITE);
+            StdDraw.setPenRadius(0.002);
+            PathfinderVisualizer.drawCircle(loc, N, 2.0);
+        }
+
+        // write status text
+        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
+        StdDraw.setPenColor(StdDraw.BLACK);
+        StdDraw.text(96, 12, "heuristic: " + pf.getHeuristic());
+        if(pf.foundPath()) StdDraw.text(256, 12, "path: " + pf.getPathCost());
+        else               StdDraw.text(256, 12, "no path found");
+        StdDraw.text(512-96, 12, "searched: " + pf.getSearchSize() + " (" + (int)(100.0f * pf.getSearchSize() / (N*N)) + "%)");
+    }
+}
+
+--[ 2022.11.05.15.36.53.023.1 ]--
+InitFile: /src/Pathfinder.java
+import java.lang.IndexOutOfBoundsException;
+import java.lang.IllegalArgumentException;
+
+/**
+ * Pathfinder uses A* search to find a near optimal path
+ * between to locations with given terrain.
+ */
+//hiiiiiiiiiiii
+    //this is Makayla...
+public class Pathfinder {
+
+    /**
+     * PFNode will be the key for MinPQ (used in computePath())
+     */
+    private class PFNode implements Comparable<PFNode> {
+        // loc: the location of the PFNode
+        // fromNode: how did we get here? (linked list back to start)
+        Coord location;
+        PFNode previous;
+        float cost;
+        public PFNode(Coord loc, PFNode fromNode, float newCost) {
+           location=loc;
+           previous=fromNode;
+           cost=newCost;
+        }
+
+        // compares this with that, used to find minimum cost PFNode
+        public int compareTo(PFNode that) {
+            return this.compareTo(that);
+        }
+
+        // returns the cost to travel from starting point to this
+        // via the fromNode chain
+        public float getCost(float heuristic) {
+
+            return 0;
+        }
+
+        // returns if this PFNode is still valid
+        public boolean isValid() {
+            return false;
+        }
+
+        // invalidates the PFNode
+        public void invalidate() {
+        }
+
+        // returns if the PFNode has been used
+        public boolean isUsed() {
+            return true;
+        }
+
+        // uses the PFNode
+        public void use() { }
+
+        // returns an Iterable of PFNodes that surround this
+        public Iterable<PFNode> neighbors() {
+            Stack<PFNode> s = new Stack<>();
+            s.push(new PFNode(null, null, 0));
+            return s;
+        }
+    }
+
+    public Pathfinder(Terrain terrain) {
+    }
+    Coord pathStart=null;
+    Coord pathEnd=null;
+    float heuristic = 1;
+    boolean pathFound=false;
+    public void setPathStart(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathStart=loc;
+    }
+
+    public Coord getPathStart() { // this function is a little redundant if we
+                                  // just have a global var for it anyway...
+        return pathStart;
+    }
+
+    public void setPathEnd(Coord loc) {
+        if(loc==null) throw new IllegalArgumentException("Illegal Arguement");
+        pathEnd=loc;
+    }
+
+    public Coord getPathEnd() {
+        return pathEnd;
+    }
+
+    public void setHeuristic(float v) {
+        heuristic=v;
+    }
+
+    public float getHeuristic() {
+        return heuristic;
+    }
+
+    //cleans out the queues ??
+    public void resetPath() {
+    }
+
+    public void computePath() {
+        // make the priorety queue
+        Terrain map = new Terrain("maze232_0.png.emap");
+        MinPQ<PFNode> PQ = new MinPQ<>();
+        PFNode start = new PFNode(pathStart, null, 0);
+        PQ.insert(start);
+        while (!pathFound) {
+            PFNode location = PQ.delMin();
+
+            if (location.location == pathEnd) {    //if the location is the end
+                pathFound = true;
+                return;
+            }
+
+            if (location == null) return;
+
+            Coord[] neighbourList = checkNeighbour(location.location);  //give all the neighbours
+            float previousCost = location.cost;
+            for (int i = 0; i < 4; i++) {
+                float cost = map.computeTravelCost(location.location, neighbourList[i]);
+                PFNode temp = new PFNode(neighbourList[i], location, cost);
+                PQ.insert(temp);
+            }
+        }
+    }
+
+    private Coord[] checkNeighbour(Coord loc){
+        int x = loc.getI();   //row
+        int y = loc.getJ();   //col
+
+        Coord[] neighbourList = new Coord[4];
+        neighbourList[0] = loc.add(0, 1);   //up
+        neighbourList[1] = loc.add(-1, 0);  //left
+        neighbourList[2] = loc.add(0, -1);  //down
+        neighbourList[3] = loc.add(1, 0);   //right
+
+        //edge cases
+
+        return neighbourList;
+
+    }
+
+    public boolean foundPath() {
+        return pathFound;
+    }
+
+    public float getPathCost() {
+        return 0;
+    }
+
+    public int getSearchSize() {
+        return 0;
+    }
+
+    public Iterable<Coord> getPathSolution() {
+        return null;
+    }
+
+    public boolean wasSearched(Coord loc) {
+        return false;
+    }
+}
+
+--[ 2022.11.05.15.37.05.647.0 ]--
+UpdateTree (AD): 0 1
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+
+--[ 2022.11.05.15.37.05.668.0 ]--
+UpdateTree (AD): 1 1
+- /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
++ /.idea/shelf/Uncommitted_changes_before_Update_at_10_29_22,_1_50_PM_[Default]/shelved.patch
+
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"testingpush\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.log/history.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.log/history.log\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/Pathfinder.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/Pathfinder.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CreatePatchCommitExecutor\">\n    <option name=\"PATCH_PATH\" value=\"\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n    <option name=\"UPDATE_TYPE\" value=\"REBASE\" />\n  </component>\n  <component name=\"MavenImportPreferences\">\n    <option name=\"generalSettings\">\n      <MavenGeneralSettings>\n        <option name=\"mavenHome\" value=\"Bundled (Maven 3)\" />\n      </MavenGeneralSettings>\n    </option>\n  </component>\n  <component name=\"ProjectId\" id=\"1iwYeHoVYqUfESIMNqB9GfLh0Bl\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"PropertiesComponent\">\n    <property name=\"FullScreen\" value=\"false\" />\n    <property name=\"OverrideImplement.combined\" value=\"true\" />\n    <property name=\"OverrideImplement.overriding.sorted\" value=\"false\" />\n    <property name=\"dynamic.classpath\" value=\"false\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\n    <property name=\"project.structure.last.edited\" value=\"Libraries\" />\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\n    <property name=\"recentsLimit\" value=\"5\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"preferences.pluginManager\" />\n    <property name=\"settings.editor.splitter.proportion\" value=\"0.2\" />\n  </component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"Applet\">\n      <option name=\"POLICY_FILE\" value=\"$APPLICATION_HOME_DIR$/bin/appletviewer.policy\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidRunConfigurationType\" factoryName=\"Android App\">\n      <option name=\"DEPLOY\" value=\"true\" />\n      <option name=\"DEPLOY_APK_FROM_BUNDLE\" value=\"false\" />\n      <option name=\"DEPLOY_AS_INSTANT\" value=\"false\" />\n      <option name=\"ARTIFACT_NAME\" value=\"\" />\n      <option name=\"PM_INSTALL_OPTIONS\" value=\"\" />\n      <option name=\"ALL_USERS\" value=\"false\" />\n      <option name=\"ALWAYS_INSTALL_WITH_PM\" value=\"false\" />\n      <option name=\"DYNAMIC_FEATURES_DISABLED_LIST\" value=\"\" />\n      <option name=\"ACTIVITY_EXTRA_FLAGS\" value=\"\" />\n      <option name=\"MODE\" value=\"default_activity\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <option name=\"DEEP_LINK\" value=\"\" />\n      <option name=\"ACTIVITY_CLASS\" value=\"\" />\n      <option name=\"SEARCH_ACTIVITY_IN_GLOBAL_SCOPE\" value=\"false\" />\n      <option name=\"SKIP_ACTIVITY_VALIDATION\" value=\"false\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"AndroidTestRunConfigurationType\" factoryName=\"Android Instrumented Tests\">\n      <option name=\"TESTING_TYPE\" value=\"0\" />\n      <option name=\"METHOD_NAME\" value=\"\" />\n      <option name=\"CLASS_NAME\" value=\"\" />\n      <option name=\"PACKAGE_NAME\" value=\"\" />\n      <option name=\"INSTRUMENTATION_RUNNER_CLASS\" value=\"\" />\n      <option name=\"EXTRA_OPTIONS\" value=\"\" />\n      <option name=\"INCLUDE_GRADLE_EXTRA_OPTIONS\" value=\"true\" />\n      <option name=\"RETENTION_ENABLED\" value=\"No\" />\n      <option name=\"RETENTION_MAX_SNAPSHOTS\" value=\"2\" />\n      <option name=\"RETENTION_COMPRESS_SNAPSHOTS\" value=\"false\" />\n      <option name=\"CLEAR_LOGCAT\" value=\"false\" />\n      <option name=\"SHOW_LOGCAT_AUTOMATICALLY\" value=\"true\" />\n      <option name=\"INSPECTION_WITHOUT_ACTIVITY_RESTART\" value=\"false\" />\n      <option name=\"TARGET_SELECTION_MODE\" value=\"EMULATOR\" />\n      <option name=\"DEBUGGER_TYPE\" value=\"Java\" />\n      <Java />\n      <Profilers>\n        <option name=\"ADVANCED_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"STARTUP_CPU_PROFILING_CONFIGURATION_NAME\" value=\"Sample Java Methods\" />\n        <option name=\"STARTUP_NATIVE_MEMORY_PROFILING_ENABLED\" value=\"false\" />\n        <option name=\"NATIVE_MEMORY_SAMPLE_RATE_BYTES\" value=\"2048\" />\n      </Profilers>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"InteractivePathfinderVisualizer\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"InteractivePathfinderVisualizer\" />\n      <module name=\"P04_Pathfinding\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Application\" factoryName=\"Application\">\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JUnit\" factoryName=\"JUnit\">\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$MODULE_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JarApplication\">\n      <option name=\"JAR_PATH\" value=\"$PROJECT_DIR$/src/stdlib.jar\" />\n      <method v=\"2\" />\n    </configuration>\n    <configuration default=\"true\" type=\"TestNG\">\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <properties />\n      <listeners />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"#org.jetbrains.idea.devkit.run.PluginConfigurationType\">\n      <module name=\"\" />\n      <option name=\"VM_PARAMETERS\" value=\"-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea\" />\n      <option name=\"PROGRAM_PARAMETERS\" />\n      <predefined_log_file enabled=\"true\" id=\"idea.log\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.InteractivePathfinderVisualizer\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SvnConfiguration\">\n    <configuration />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"50b83df3-15a9-4360-bde3-1e23007b18a2\" name=\"Default\" comment=\"\" />\n      <created>1437589218980</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1437589218980</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"testingpush\">\n      <created>1666713359136</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1666713359137</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"testingpush\">\n      <created>1666787253246</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1666787253246</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"computePath\">\n      <created>1667065443757</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1667065443757</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"4\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.UiProperties\">\n    <option name=\"RECENTLY_FILTERED_USER_GROUPS\">\n      <collection />\n    </option>\n    <option name=\"RECENTLY_FILTERED_BRANCH_GROUPS\">\n      <collection />\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"testingpush\" />\n    <MESSAGE value=\"computePath\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"computePath\" />\n  </component>\n  <component name=\"antWorkspaceConfiguration\">\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\n  </component>\n  <component name=\"masterDetails\">\n    <states>\n      <state key=\"ArtifactsStructureConfigurable.UI\">\n        <settings>\n          <artifact-editor />\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"FacetStructureConfigurable.UI\">\n        <settings>\n          <last-edited>No facets are configured</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"GlobalLibrariesConfigurable.UI\">\n        <settings>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"JdkListConfigurable.UI\">\n        <settings>\n          <last-edited>1.8</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ModuleStructureConfigurable.UI\">\n        <settings>\n          <last-edited>P04_Pathfinding</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n                <option value=\"0.6\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectJDKs.UI\">\n        <settings>\n          <last-edited>1.7</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n      <state key=\"ProjectLibrariesConfigurable.UI\">\n        <settings>\n          <last-edited>algs4</last-edited>\n          <splitter-proportions>\n            <option name=\"proportions\">\n              <list>\n                <option value=\"0.2\" />\n              </list>\n            </option>\n          </splitter-proportions>\n        </settings>\n      </state>\n    </states>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision f17257c6cddd76fb6c04620a5cca5065726c7022)
+++ b/.idea/workspace.xml	(date 1667677033472)
@@ -1,10 +1,15 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="testingpush">
+    <list default="true" id="50b83df3-15a9-4360-bde3-1e23007b18a2" name="Default" comment="updated version">
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22,_11_54_AM_[Default]/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_25_22__11_54_AM__Default_.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_11_45_AM_[Default]/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22,_9_22_AM_[Default]/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__11_45_AM__Default_.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10_26_22__9_22_AM__Default_.xml" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.log/history.log" beforeDir="false" afterPath="$PROJECT_DIR$/.log/history.log" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/Pathfinder.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Pathfinder.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -24,6 +29,9 @@
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
     <option name="UPDATE_TYPE" value="REBASE" />
+  </component>
+  <component name="MarkdownSettingsMigration">
+    <option name="stateVersion" value="1" />
   </component>
   <component name="MavenImportPreferences">
     <option name="generalSettings">
@@ -34,6 +42,10 @@
   </component>
   <component name="ProjectId" id="1iwYeHoVYqUfESIMNqB9GfLh0Bl" />
   <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
   <component name="PropertiesComponent">
     <property name="FullScreen" value="false" />
     <property name="OverrideImplement.combined" value="true" />
@@ -163,6 +175,7 @@
       </list>
     </recent_temporary>
   </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="SvnConfiguration">
     <configuration />
   </component>
